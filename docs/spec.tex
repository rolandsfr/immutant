\documentclass[12pt,a4paper]{report}

\usepackage{formatting}
\usepackage{tabularx}
\usepackage{cite}  % optional, improves formatting
\usepackage{graphicx}
\usepackage{multirow}
\usepackage{booktabs}
\usepackage[table]{xcolor}
\usepackage{placeins}
\usepackage{longtable}
\usepackage{caption}
\usepackage{forest}

\hfuzz=100pt  % ignores overfull hboxes less than 100pt
\vfuzz=100pt  % ignores overfull vboxes less than 100pt

\title{LATVIJAS UNIVERSITĀTE
EKSAKTO ZINĀTŅU UN TEHNOLOĢIJU FAKULTĀTE}

\author{Rolands Frīdemanis}


\begin{document}

\begin{titlepage}
    \centering
    
    {\Large LATVIJAS UNIVERSITĀTES\\EKSAKTO ZINĀTŅU UN TEHNOLOĢIJU FAKULTĀTES DATORIKAS NODAĻA\\[5cm]}
    
    {\LARGE \textbf{ INTERPRETATORS PROGRAMMĒŠANAS\\[0.3cm] VALODAI IMMUTANT}}\\[0.5cm]

    \normalsize{KVALIFIKĀCIJAS DARBS DATORZINĀTNĒS}\\[5cm]
    
    \begin{flushleft}
        Autors: Rolands Frīdemanis\\
        Studenta apliecības Nr.: rf23009\\
        Darba vadītājs: Dr. dat. Aleksandrs Belovs
    \end{flushleft}
    
    \vfill
    RĪGA, 2025
\end{titlepage}

\selectlanguage{latvian} 
\begin{abstract}
    Mūsdienās liela daļa no vispārīga pielietojuma programmēšanas valodām, satur semantiku, kas paredz, ka datu mainība ir ierasta lieta, tomēr šim pastāv būtisks trūkums, kas ir datu neparedzamība.
    Lai spriešanu par programmas stāvokli padarītu paredzamu, šī darba ietvaros tiek izstrādāta programmēšanas valoda, kuras gramatika un sintakse ierosina noteikta datu nemainību.
    Šis darbs satur valodas specifikāciju un interpretatora arhitektūras dokumentāciju skenerim, parsētājam un abstraktā sintakses koka pārstaigāšanas algoritmam.
    Rezultātā, izmantojot valodu C, tiek izveidota augsta līmeņa, intepretējama, dinamiski tipizēta valoda ar atomāriem datu tipiem.

    \begin{flushleft}
    \textbf{Atslēgvārdi:} interpretators, AST, funkcionālā programmēšana, C valoda, datu nemainība
    \end{flushleft}
\end{abstract} 

\selectlanguage{english} 
\begin{abstract}
    Most modern general-purpose programming languages use grammar and syntax that suggests mutable data being an ordinary matter, which in reality complicates reasoning about program state.
    To make such reasoning predictable, this work explores the design and development of a programming language with explicit syntax and semantics of immutable data. 
    This work contains specification for such language and documentation of the architecture for the lexer, parser and AST-walk evaluation of the underlying interpreter.
    As a result, a high-level, interpreted, dynamically typed programming language with only atomic data types is created. The language is implemented in C.

    \begin{flushleft}
    \textbf{Keywords:} interpreter, AST, functional programming, C language, data immutability
    \end{flushleft}
\end{abstract} 

\selectlanguage{latvian} 
\tableofcontents

\newpage
\chapter*{Apzīmējumu saraksts un terminu skaidrojumi}
\addcontentsline{toc}{section}{Apzīmējumu saraksts un terminu skaidrojumi}

\begin{itemize}
  \item \textbf{AST} - Abstraktās sintakses koks - koka datu struktūra.
  \item \textbf{mutabilitāte} - Datu īpašība, kas ļauj mainīt to vērtību pēc sākotnējās inicializācijas. Programmēšanas valodas kontekstā tā izpaužas kā interpretatora uzvedība caur valodas semantiku, kas ļauj mainīt datu vērtības izpildes laikā \cite{immutability}.
\item \textbf{mutabls} - mutabilitātes īpašība, kas ļauj mainīt datu vērtību pēc sākotnējās inicializācijas. 
  \item \textbf{nemutabls} - mutabilitātes īpašība, kas neļauj mainīt datu vērtību pēc sākotnējās inicializācijas.
\item \textbf{Immutant} - Jauna pašizveidota interpretējama programmēšanas valoda ar datu nemainības semantiku, kas apskatīta šajā darbā.

  \item \textbf{lvalue} - Angļu valodā ``left value`` jeb saīsināti lvalue - izteiksme, kas apzīmē atmiņas vietu, kurā var glabāt vērtību.
  \item \textbf{REPL} - Angļu valodā ``Read-Eval-Print Loop`` - interaktīva vide, kas ļauj lietotājam ievadīt kodu, to izpildīt un redzēt rezultātu tūlītēji.
  % UAT, LSP
  \item \textbf{UAT} - Angļu valodā ``User Acceptance Testing`` - lietotāja akceptēšanas testēšana - programmatūras testēšanas veids, kurā galalietotāji pārbauda sistēmu, lai pārliecinātos, ka tā atbilst viņu prasībām un ir gatava lietošanai.
  \item \textbf{LSP} - Angļu valodā ``Language Server Protocol`` - valodas servera protokols - standarts, kas ļauj izstrādes rīkiem un redaktoriem sazināties ar programmēšanas valodu serveriem, lai nodrošinātu funkciju automātisko pabeigšanu, sintakses izcelšanu un kļūdu pārbaudi.
\end{itemize}

\newpage
\chapter*{Ievads}
\addcontentsline{toc}{section}{Ievads}

Datu mainība un to nepārtraukta plūsma no viena mainīga uz otru ir neapstrīdama daļa no lielas daļas programmatūras. Droši var apgalvot, ka datorsistēmu arhitektūru atmiņas koncepcija ļauj izmantot atmiņu vairākkārtēji. Atmiņu var pārvietot, izdzēst, pieprasīt lielākus atmiņas gabalus u.t.t. No šī izriet datu mainības būtība, un līdz šai dienai tā ir iekalta lielā daļā, ja ne visu, programmēšanas valodu.   

No otras puses, mainīgiem datiem pastāv īpašība būt neparedzamiem. Kamēr mazas sistēmas spēj tikt galā ar nelielu daudzumu mainīgo, tad lielajās sistēma tas var kļūt par acīmredzamu problēmu. Atmiņa datoram ir viena, tomēr atsaukties uz to var no dažādām vietām dažādos laika brīžos, kas padara spriešanu par datu stāvokli daudz sarežģītāk.  

Programmētāji izmanto iespēju mainīt datus brīvā veidā, jo  programmēšanas valodas un to abstrakcijas ir padarījušas to tik vienkāršu. Lai gūtu vairāk kontroles pār iepriekš minēto uzvedību, valodas no C saimes, Java, JavaScript un citas valodas satur gramatikas, kas ierobežo mainīgu datu inicializāciju un to turpmāko vērtību maiņu. Kā piemēru var minēt \texttt{const} atslēgvārdu no valodas C, kas fiksē doto mainīgo un liedz pārrakstīt tā vērtību, tomēr tas tikai daļēji attiecas uz atsauces tipa vērtībām. Kaut arī šāda tipa mainīgais vienmēr atsauksies tikai uz vienu konkrētu atmiņas apgabalu, nav noteikts, ka vērtība, kas tajā atrodas, nemainīsies. Līdz ar to, \texttt{const} atslēgvārds negarantē patiesu datu nemainību, bet tikai noslēdz to uz \texttt{readonly} pieeju.
Neskatoties uz dažādiem programmēšanas valodu centieniem ierobežot datu mainību, tādas problēmas kā neparedzamas mainīgo vērtības pavedienu izpildes laikā, mainīgo aizstājvārdu nepārdomāta ieviešana un izmantošana, mainīgo nejauša re-inicializācija u.c. joprojām sastāda lielu daļu programmu.\cite{immutability}

Šis darbs izskata jaunas interpretējamas programmēšanas valodas izveidi, kurai pielietota datu nemainības semantika, cenšoties mazināt programmatūras izstrādes problēmas saistītas ar stāvokļu maiņu. Tas arī nozīmē, ka galvenā valodas ideja ir faktors valodas nosaukuma izvēlei. Savukārt interpretatora sākotnējā versijā, kas šeit ir izskatīta, ietilpst apstrādes loģika sekojošām daļām: primitīvi datu tipi un to glabāšana mainīgos, ar to saistītā datu nemainības semantika, izteiksmes, tīras un netīras funkcijas, kontroles plūsma un cikli.

\subsubsection{Valodas nolūks}
Valodas Immutant galvenais mērķis ir nodrošināt vienkāršu, viegli apgūstamu programmēšanas valodu, ar datu nemainības semantiku, kas ļauj izstrādāt programmatūru ar minimālu blakus efektu risku, ko rada datu mainība. Valoda ir paredzēta gan iesācējiem programmētājiem, gan pieredzējušiem izstrādātājiem, kas vēlas izmantot datu nemainības priekšrocības savos projektos. 



\subsubsection{Pārskats}

Šī darba pirmajā nodaļā lasītāji tiek iepazīstināti ar produkta potenciālu un tiek sniegti īsu vispārēju pārskatu. Savukārt otrā nodaļa nostāda prasības uz valodas specifikāciju. Trešā un ceturtā nodaļa raksturo programmatūras projektējumu un piektā nodaļa satur testēšanas plānu. Pārējās nodaļas nesatur tehnisku informāciju, bet gan raksturo projekta īstenošanas procesu.
Pēdējā nodaļa ir veltīta secinājumiem un turpmākajām darba iespējām.

\newpage
\chapter{Vispārējs apraksts}

\section{Esošā stāvokļa apraksts}
Uz doto brīdi eksistē vairākas programmēšanas valodas, kas piedāvā dažādus līmeņus datu nemainības atbalstam. Piemēram, funkcionālās programmēšanas valodas kā Haskell un Clojure ir veidotas ap datu nemainības principiem, nodrošinot spēcīgu atbalstu nemutabliem datiem un tīrām funkcijām \cite{haskell, clojure}. No otras puses, imperatīvās valodas kā Python un JavaScript piedāvā iespējas strādāt ar nemutabliem datiem, bet tās nav tik stingras kā funkcionālajās valodās \cite{python, ecma-262}.

\section{Pasūtītājs}
Sistēma tiek izstrādāta pēc autora iniciatīvas kvalifikācijas darba ietvaros. 

\section{Produkta perspektīva}
Jaunā programmēšanas valoda Immutant ir paredzēta kā patstāvīgs produkts, kas var tikt izmantots kā rīks dažādiem programmēšanas projektiem. Tā nav atkarīga no jebkuras konkrētas platformas vai sistēmas.

\section{Produkta funkcijas}
Valoda Immutant piedāvā šādas galvenās funkcijas:

\begin{itemize}
  \item \textbf{Datu nemainība:} Valoda Immutant ievieš stingru datu nemainības semantiku, kas nozīmē, ka pēc datu inicializācijas to vērtības nevar mainīt. Tas palīdz samazināt blakusefektu risku un padara programmas uzvedību paredzamu.
  \item \textbf{Vienkārša sintakse:} Valodas sintakse ir veidota tā, lai tā būtu viegli saprotama un lietojama, padarot to pievilcīgu gan iesācējiem, gan pieredzējušiem programmētājiem.
  \item \textbf{Dinamiskā tipizācija:} Valoda Immutant izmanto dinamisko tipizāciju, kas ļauj programmētājiem strādāt ar dažādiem datu tipiem bez nepieciešamības deklarēt to tipus pirms lietošanas.
  \item \textbf{Funkcionālā programmēšana:} Valoda atbalsta daļu no funkcionālās programmēšanas paradigmām, nodrošinot izpildlaikā verificējamas tīras funkcijas, kas palīdz samazināt blakusefektu risku.
\end{itemize}

\section{Darījumprasības}

Programmatūrai ir izveidotas šādas darījumprasības:

\begin{itemize}
  \item Valodas sintakse un semantika jābūt viegli saprotamai un lietojamai, lai veicinātu plašu pieņemšanu starp programmētājiem.
  \item Intepretatoram ir jāatbalsta gan interarktīvās vides režīmu, gan skriptu izpildi no datnēm.
\end{itemize}

\section{Sistēmas lietotāji}
Sistēmas galvenie lietotāji ir programmētāji, kas vēlas izmantot datu nemainības priekšrocības savos projektos. Tie var būt gan iesācēji, kas mācās programmēšanu, gan pieredzējuši izstrādātāji, kas meklē jaunu rīku saviem projektiem. Spēkā ir pieņēmums, ka lietotājam ir pamata izpratne par programmēšanas jēdzieniem un terminoloģiju un tas ir iepazinies ar programmēšanas valodu Immutant dokumentāciju.

\begin{figure}[h]   
    \centering
    \includegraphics[scale=0.6]{assets/dataflow/dfd_lvl_0.jpg}  
    \vspace{0.5cm}  
    \caption{0. līmeņa datu plūsmas diagramma}           % optional
    \label{fig:dfd_lvl_0}                  
\end{figure}

\section{Vispārējie ierobežojumi}
Interpretators ticis izstrādāts Mac OS platformai, tāpēc tiek pieņemts, ka lietotājam darbojas šajā operētājsistēmā. Tomēr interpretatora kods ir rakstīts tā, lai to būtu viegli pārnest uz citām platformas ar minimālām izmaiņām. 


\section{Pieņēmumi un atkarības}

\begin{itemize}
  \item Pirmkoda datnes, kas tiek padotas izpildei interpretatoram nav aizsargātas pret lasīšanu. 
  \item Pirmkods ir rakstīts atbilstoši valodas Immutant gramatikai un sintaksei.
\end{itemize}

\newpage


\chapter{Valodas specifikācija}

Šīs nodaļas nolūks ir formalizēt prasības, kas noteiktas uz valodu, kas interpretatoram ir jāspēj īstenot. Šī nodaļa neizklāsta implementācijas detaļas, bet gan drīzāk kalpo kā lietotāja rokasgrāmata valodas lietošanā.
Nodaļā izklāstītā informācija ne tikai palīdz lasītājiem iepazīties ar tās uzbūvi valodas lietošanas un attīstības nolūkos, bet arī nosaka prasības, kas tiek attiecīgi nostādītas uz Immutant programmēšanas valodas interpretatoru.
Nodaļā ir skaidroti valodā definētie datu tipi, mainīgie funkcijas, un programmas vadības mehānismi, datu nemainības semantika, kas attiecas uz noteikta veida vērtībām, kā arī tiek uzskaitīti kļūdu paziņojumi un to attiecīgie skaidrojumi.

\section{Datu tipi}

Programmēšanas valodas pamatu veidu datu tipi un ar to saistītie mehānismi. Valodā Immutant tiek definēti tikai primitīvie datu tipi, kas satur skaitļus, virknes un patiesuma vērtības. Datu tipizācija ir dinamiska, kas nozīmē, ka datu tipa pārbaude tiek veikta izpildes laikā.

\subsection{Primitīvie datu tipi}

Pirmatnējā Immutant valodas versijas tipu sistēma ietver tikai primitīvos datu tipus, t.i., pamata datu tipi, no kuriem potenciāli var veidot citus saliktus tipus, piemēram, masīvus, objektus u.c.  Salikti datu tipi netiek iekļauti valodas versijā, kas tiek aprakstīta šajā dokumentā, lai saglabātu interpretatora vienkāršību un vairāk koncentrētos uz datu nemainības semantikas īstenošanu.

\subsubsection{Virknes}
Virkne ir jebkurš simbolu kopums, kas ir ietverts starp pēdiņām.
Tās var saturēt jebkādus simbolus, tostarp spec-simbolus, kā \texttt{@,\^\space,\&} u.c. Proti, virknēs nav liegts izmantot speciālos atslēgas vārdus, ko pati valoda ir definējusi, piemēram, \texttt{mut} (vairāk par to minēts sadaļā ~\ref{section:vars}).
Piemērs dažādām virknēm seko zemāk. Tāpat, arī tikai vienu rakstzīmi ir atļauts uzdot ar virknes tipu.

\begin{verbatim}
"", "someString", "garumzīmes īāē", " ", ,"\""
\end{verbatim}

Izņēmuma gadījums, ir pēdiņu simbola izmantošana iekš virknes. Lai neuztvertu to kā virknes beigas, tas ir jāekranē ar vadošo simbolu \texttt{\textbackslash}. Realitātē neekranizētas virknes, kas satur spec-simbolus ir pamata sintakses kļūda, ko programmētāji bieži vien pieļauj neuzmanības dēļ. 

Piemērs tādai virknei:

\begin{verbatim}
"They call themselves \"the wolves\""
\end{verbatim}

Rezultātā atkārtots pēdiņu simbols netiek uztvers kā virknes beigu indikators, bet gan kā daļa no virknes vērtības, un tiek panākts sekojošs teksts:

\begin{verbatim}
They call themselves "the wolves"
\end{verbatim}

Uz ekranizēšanu attiecas arī pats ekranizēšanas simbols \texttt{\textbackslash}. Ja ir nepieciešamība to iekļaut virknē, tas arī ir jāekranizē sekojošā veidā:

\begin{verbatim}
"There is something mysterious about the \"\\\" character."
\end{verbatim}

Dotās virknes rezultējošais teksts ir: 

\begin{verbatim}
There is something mysterious about the "\" character.
\end{verbatim}

\subsubsection{Skaitļi}

Skaitlis ir jebkura vērtība no reālo skaitļu kopas. Ir svarīgi uzsvērt, ka iracionāli skaitļi tiek implementēti pēc IEEE 754 standarta, tāpēc realitātē tie nav līdz galam iracionāli, bet gan ir to aproksimētas vērtības. Daļskaitļu decimālo daļu atdala ar punkta (\char`.) rakstzīmi.

Piemērs skaitliskām vērtībām seko zemāk:

\begin{verbatim}
102, -9, -0.3, 421.5632, PI
\end{verbatim}

Dotajā piemērā \texttt{PI} ir viena no valodā eksistējošām konstantēm, kas satur aproksimētu matemātiskās konstantes $\pi$ vērtību (\texttt{\char`~3.1415926535}).

Valodas gramatika atļauj izmantot vadošo punktu priekšā skaitlim, kas apzīmē decimāldaļu skaitlim nulle. Piemēram, decimālskaitlis \texttt{.34} ir identisks ar \texttt{0.34}.


\subsubsection{Patiesuma vērtības}

Patiesuma vērtības valodā Immutant seko divvērtīgai loģikai, kur ir tikai divas iespējamās vērtības: patiesa un aplama. Patiesu vērtību apzīmē ar \texttt{true}, bet aplamu ar \texttt{false}. Patiesuma vērtības ir pamats loģiskām izteiksmēm, kas tiek izmantotas kontroles plūsmas konstrukcijās, piemēram, nosacījumos un ciklos. 

Patiesuma vērtību var iegūt vai nu to tieši uzdodot, vai arī piemērojot loģiskos operatorus (skat. sadaļu ~\ref{section:operators}).

\section{Mainīgie}
\label{section:vars}

Mainīgie ir programmēšanas valodas konstrukcija, kas ļauj saglabāt datus atmiņā un atsaukties uz tiem vēlāk programmā. Immutant valodā nošķir 2 veidu manīgos: tie kas nepaļaujas datu mutācijai jeb mainībai un tie, kas tai paļaujas. 

\subsection{Mainīgo deklarācija un inicializācija}

Mainīgo deklarācija ir apgalvojums, kas reģistrē mainīgā identifikatoru atmiņā, bet inicializācija ir apgalvojums, kas piešķir mainīgajam sākotnējo vērtību.

Mainīgo deklarācija un inicializācija var notikt vienā solī, vai arī tās var izpildīt atsevišķi, tomēr jātur prātā ka mainīgajam ir jābūt deklarētam pirms tā inicializācijas vai jebkādas citas izmantošanas programmā, pretējā gadījumā tiek izmests izņēmums \texttt{RUNTIME\_ERR-2}.

Mainīgos deklarē sekojošā formā:
\begin{verbatim}
<mutability> <identifier>;
\end{verbatim}


Mainīgā deklarācija sākas ar vienu no 2 atslēgvārdiem <mutability> - \texttt{mut} un \texttt{imut} -, kas nosaka mainīgā mutācijas īpašību. 

Mainīgo deklarāciju nobeidz patvaļīgs identifikators <identifier> jeb mainīgā nosaukums. Identifikators var saturēt burtus, ciparus un pasvītrojuma simbolu (\texttt{\_}), bet nedrīkst sākties ar ciparu. Tāpat, identifikators nedrīkst sakrist ar kādu no valodas atslēgvārdiem, piemēram, \texttt{mut}, \texttt{imut}, \texttt{if}, \texttt{else} u.c. (pilnu atslēgvārdu sarakstu skatīt sadaļā ~\ref{section:keywords}).

Mainīgā inicializācijai ir jāseko vienai no sekojošām formām:

\begin{verbatim}
<identifier> = <expression>;
\end{verbatim}  

\begin{verbatim}
<mutability> <identifier> = <expression>;
\end{verbatim}  

Pirmo gadījumu lieto, ja mainīgā deklarācija ir veikta iepriekš, bet otro, ja mainīgā deklarācija un inicializācija notiek vienlaicīgi.

Lai inicializētu mainīgo, t.i. piešķirtu tam vērtību, ir jāizmanto piešķiršanas operatora simbols (\texttt{=}), kam seko izteiksme <expression>, kas rezultātā atgriež vērtību, ko piešķir mainīgajam.

\subsection{Mainīgo mutabilitāte}
\label{section:var-mutability}

Mainīgo mutabilitāte jeb mainības īpašība nosaka, vai mainīgā vērtību ir iespējams mainīt pēc tā inicializācijas. 
Valodā Immutant ir divu veidu mainīgie: \textbf{mutable} un \textbf{immutable}, tos deklarē izmantojot atslēgvārdus \texttt{mut} un \texttt{imut} attiecīgi. Turpmāk šajā darbā tiks izmantoti šo terminu latviešu atvasinājumi, t.i., \textbf{mutabilitāte, mutabls} un \textbf{nemutabilitāte, nemutabls} lai raksturotu datu mainības īpašības.

\subsubsection{Mutabilitāte \texttt{mutable}}

Mutabls, atvasināts no angļu valodas vārda \texttt{mutable}, ir tāds mainīgais, kura vērtību ir iespējams mainīt pēc tā inicializācijas. Tādus mainīgos deklarē ar atslēgvārdu \texttt{mut}.

Jebkuram mainīgajam, kas deklarēts ar \texttt{mut}, var tikt piešķirta jauna vērtība jebkurā programmas izpildes brīdī pēc tā inicializācijas. Tas ļauj programmētājiem veidot dinamiskākas programmas, kurās dati var mainīties atkarībā no programmas loģikas un lietotāja ievades. Proti, to ir ieteicams darīt tikai gadījumos, kad risinājumi ar nemutabliem mainīgajiem ir pārāk sarežģīti vai neefektīvi.

\subsubsection{Mutabilitāte \texttt{immutable}}

Nemutabls, atvasināts no angļu valodas vārda \texttt{immutable}, ir tāds mainīgais, kura vērtību nav iespējams mainīt pēc tā inicializācijas. Tādus mainīgos deklarē ar atslēgvārdu \texttt{imut}. Atslēgvārds \texttt{imut} ir saīsinājums no \texttt{immutable}, kas apzīmē mainīgo, kas nav maināms. Tas atbilst nemutabilitātes semantikai, kas izmantota funkcionālajā programmēšanā.

Nemutablus mainīgos nedrīkst re-inicializēt. Tas nozīmē, ka sekojoša programma izmetīs kļūdu \texttt{RUNTIME\_ERR-11}
\begin{verbatim}
imut x = 10;
x = 20; // kļūda
\end{verbatim}

Tā kā valodā Immutant netiek definēti sarežģītāki datu tipi, piemēram, masīvi vai objekti, tad nav nepieciešams apskatīt mutabilitātes īpašības attiecībā uz šādiem datu tipiem. 

\subsection{Datu tipa konversija}
\label{section:datatype-conversion}

Pastāv gadījumi, kad parādās nepieciešamība konvertēt viena datu tipa vērtību uz cita datu tipa vērtību. Piemēram, ja kādu aritmētisku operatoru, piemēram, saskaitīšanu, pielieto virknei un skaitlim. Tad ir nepieciešams konvertēt vienu no operandiem uz otra datu tipu, lai veiktu šo operāciju, šajā gadījumā virkne jāpārveido uz skaitli vai skaitlis par virkni. 

Daudzās valodās eksistē netiešā datu tipu konversija jeb tā, ko interpretators pats veic pēc vajadzības. Piemēram, valodā Javascript izteiksme \texttt{"5" + 3} rezultātā atgriež virkni \texttt{"53"}, jo interpretators veic netiešo tipu konversiju, pārvēršot skaitli \texttt{3} par virkni \texttt{"3"} un pēc tam veicot virkņu konkatenāciju \cite{ecma-262}. Šī ir gan priekšrocība, jo operators tiek netieši pārslogots uz darbību ar virknēm, nevis skaitļiem, tomēr tas var novest pie neparedzamas uzvedības, kas zināmā veidā liek smieties, par to, kā Javascript valodā izteiksmes  "5" + 3 rezultāts ir "53", nevis 8, tomēr tam arī atrodams loģisks skaidrojums.

Tā kā programmēšanas valodas Immutant galvenais mērķis ir palīdzēt programmētājiem rakstīt paredzamāku kodu, datu tipu konversija tiek atbalstīta tikai tiešā veidā. Tas nozīmē, ka saskaitot virkni un skaitli, nav jāpiedomā vai rezultātā radīsies virkne vai skaitlis, jo zināms, ka neviennozīmīgu operāciju izpilde izmetīs izpildlaika kļūdu.

No otras puses, ja programmas autors tiešām vēlas pārveidot vienu datu tipu uz citu, tad valoda Immutant piedāvā iebūvētas funkcijas, kas veic šo darbību. Šīs funkcijas ir aprakstītas zemāk:

\begin{itemize}
  \item \texttt{toString(value)} - Atgriež `value` vērtību pārvēstu virknes datu tipā.
  Pārvēršanas loģika - doto vērtību pārvērš par virkni, izmantojot tās bāzes reprezentāciju. Piemēram, skaitlis \texttt{42} tiek pārvērsts par virkni \texttt{"42"}, bet patiesuma vērtība tiek pārvērsta par virkni \texttt{"true"} vai \texttt{"false"} attiecīgi. 
  \item \texttt{toNumber(value)} - Atgriež vērtības skaitlisko reprezentāciju. Ja virkne satur derīgu skaitlisko vērtību, tad tā tiek pārvērsta par atbilstošu skaitli. Piemēram, virkne \texttt{"123.45"} tiek pārvērsta par skaitli \texttt{123.45}. Ja virkne nesatur derīgu skaitlisko vērtību, tiek izmests izņēmums \texttt{RUNTIME\_ERR-12}. Patiesa vērtība \texttt{true} tiek pārvērsta par skaitli \texttt{1}, bet \texttt{false} par skaitli \texttt{0}. 
  
  Virkne ir uzskatāma par derīgu skaitlisko vērtību, ja tā satur tikai skaitli vai decimālskaitli. Ja skaitlim apkārt ir tukšuma simboli, tie tiek ignorēti. Piemēram, virknes \texttt{"  42  "} un \texttt{"-3.14"} ir derīgas skaitliskās vērtības, bet virknes \texttt{"123abc"} un \texttt{"hello"} nav derīgas.
  \item \texttt{toBoolean(value)} - Pārveido dotā operanda vērtību par patiesuma vērtību. Vērtības \texttt{0}, \texttt{\char`"\char`"} (tukša virkne) un \texttt{false} tiek pārvērstas par aplamu vērtību, bet viss pārējais par patiesu.
  \item \texttt{typeOf(value)} - Atgriež dotā operanda datu tipu kā virkni. Pieņem jebkura datu tipa vērtību kā argumentu, un atgriež vienu no šādām virkņu vērtībām: \texttt{\char`"number"}, \texttt{\char`"string"}, \texttt{"boolean"}, \texttt{"function"}.
\end{itemize}

\subsection{Mainīgo redzamība}
Mainīgo redzamība nosaka kurās programmas daļas ir pieejams konkrētais mainīgais. Valodā Immutant mainīgo redzamība tiek noteikta pēc to deklarācijas vietas. Mainīgā redzesloks ir tā programmas daļa, kurā ir pieejams attiecīgais mainīgais.

Piemērs globāla mainīgā deklarācijai un tā izmantošanai funkcijā:

\begin{verbatim}
imut globalVar = 10;

fn printGlobalVar() {
  print(globalVar);
}

printGlobalVar(); // Izvada: 10
\end{verbatim}

Mainīgie, kas deklarēti ārpus jebkuras funkcijas ķermeņa, ir pieejami visā programmas kodā, ieskaitot visas funkcijas. Šādi mainīgie tiek saukti par globāliem mainīgajiem, t.i. to redzesloks aptver visu programmu.

Funkcijas un jebkādas citas konstrukcijas ar ķermeni (valodā Immutant tie arī ir cikli un nosacījumi) izveido savu redzesloku, un attiecīgi mainīgie deklarēti šajā redzeslokā ir pieejami tikai šajā konstrukcijā un tās iekšējos redzeslokos.

Piemērs lokāla mainīgā deklarācijai un tā izmantošanai funkcijā:
\begin{verbatim}
fn doMagic() {
  imut localVar = 5;
  if(true) {
    mut anotherLocalVar = localVar + 10;
  }
}
doMagic();
\end{verbatim}

Kā var redzēt, localVar eksistē visā \texttt{doMagic} funkcijas redzeslokā, tai skaitā arī nosacījuma \texttt{if} ķermenī. Šajā konkrētajā gadījumā \texttt{anotherLocalVar} ir pieejams tikai \texttt{if} ķermenī.

Mainīgie, kurus mēģina izmantot ārpus to deklarācijas redzesloka, izmet kļūdu \texttt{RUNTIME\_ERR-2}. Pēc savas būtības tā ir nedeklarēto mainīgo izmantošana. Skatīt piemēru zemāk.

\begin{verbatim}
fn setLocalVar() {
  imut localVar = 5;
}
setLocalVar();
print(localVar); // Kļūda RUNTIME_ERR-2 
\end{verbatim}

Līdzīgi situācija rodas, izmantojot mainīgo pirms tā deklarācijas:
\begin{verbatim}
print(globalVar); // Kļūda RUNTIME_ERR-2 
imut globalVar = 10;
\end{verbatim}

\section{Operatori un izteiksmes}
\label{section:operators}

\subsubsection{Izteiksmes}

Izteiksme ir valodas konstrukcija, kas atgriež kādu vērtību. Piemēram, funkcijas izsaukums ir izteiksme, kas rezultātā atgriež izpildītas funkcijas vērtību. Pie tam, arī aritmētiska vai loģiska operācija ir izteiksmes konstrukcijas, jo atgriež skaitlisku vai patiesuma vērtību attiecīgi.

\subsection{Apgalvojumi}

Apgalvojumi jeb deklarācijas ir izteiksmes, kas veic kādu darbību, bet pašas par sevi nedod nekādu vērtību. Piemēram, mainīgo inicializācija ir apgalvojums, jo tā veic darbību - piešķir vērtību mainīgajam, bet pati par sevi nedod nekādu vērtību.

Funkcijas definīcija ir apgalvojums, jo tā arī veic darbību - reģistrē funkciju atmiņā, bet pati par sevi nedod nekādu vērtību.

\subsubsection{Operatori}

Operatorus iedala unāros un bināros. Unārs operators tiek pielietots tikai vienam operandam, kur tai pat laikā bināri operatori ir pielietoti 2 operandiem. Piemēram, negācijas operators, kas apvērš patiesuma vērtību ir pielietots vienam operatoram, bet saskaitīšanas operators ir pielietots diviem skaitļiem, producējot to summu.

Vērts precizēt, ka gadījumā, ja operators ir binārs, tad tas tiek rakstīts abiem operandiem starpā. Turpmāk tekstā kreisas operands tiek definēts kā šāda bināra operatora operands, kas atrodas pa kreisi no operatora, un labais kas attiecīgi ir pa labi no tā. Piemēram, izteiksmē \texttt{23 + 45} skaitlis \texttt{23} ir kreisas operands, \texttt{45} ir labais operands, un \texttt{+} ir binārais summas operators. \\

\paragraph{Aritmētiskie operatori:} tiek pielietoti skaitļiem, un atgriež skaitlisku vērtību.

\begin{itemize}
  \item \texttt{+} saskaitīšana, atgriež divu skaitļu summu
  \item \texttt{-} atņemšana, atgriež pirmā skaitļa vērtību mīnus otrā skaitļa vērtību
  \item \texttt{*} reizināšana, atgriež divu skaitļu reizinājumu
  \item \texttt{/} dalīšana, atgriež kreisā operanda dalījumu ar labo operandu. Ja kreisais operands ir nulle, tad tiek izmesta kļūda \texttt{RUNTIME\_ERR-5}
  \item \texttt{\%} modulis, atgriež kreisā skaitļa operanda moduli ar labā operanda vērtību
\end{itemize}

\textbf{Aritmētiskās salīdzināšanas operatori:} tiek pielietoti skaitļiem, un atgriež patiesuma vērtību. 
\begin{itemize}
  \item \texttt{>} lielāks par, atgriež patiesu vērtību, ja kreisā operanda vērtība ir lielāka par labā operanda vērtību
  \item \texttt{<} mazāks par, atgriež patiesu vērtību, ja kreisā operanda vērtība ir mazāka par labā operanda vērtību
  \item \texttt{>=} lielāks vai vienāds ar, atgriež patiesu vērtību, ja kreisā operanda vērtība ir lielāka vai vienāda ar labā operanda vērtību
  \item \texttt{<=} mazāks vai vienāds ar, atgriež patiesu vērtību, ja kreisā operanda vērtība ir mazāka vai vienāda ar labā operanda vērtību
\end{itemize}

\textbf{Ekvivalences operatori:} tiek pielietoti jebkura datu tipa operandiem un atgriež patiesuma vērtību. 
\begin{itemize}
  \item \texttt{==} ir vienāds, atgriež patiesu vērtību, ja abu operandu vērtības ir vienādas. Vienmēr atgriež aplamu vērtību, ja abi operandi ir ar dažādiem datu tipiem.
  \item \texttt{!=} nav vienāds ar, atgriež patiesu vērtību, ja abu operandu vērtības nav vienādas, tai skaitā arī ja to datu tipi ir dažādi.
\end{itemize}

\textbf{Loģiskie operatori:} Pielietoti patiesuma vērtībām, un atgriež patiesuma vērtību.
\begin{itemize}
  \item \texttt{!} negācija, apvērš patiesuma vērtību. Ir unārs operators. 
  \item \texttt{\&\&} konjukcija, atgriež patiesu vērtību, ja abu operandu vērtības ir patiesas
  \item \texttt{||} disjunkcija, atgriež patiesu vērtību, ja vismaz viena no abu operandu vērtībām ir patiesa.
\end{itemize}

\subsection{Operatoru darbības kārtība}

Katram operatoram ir noteikta sava prioritāte, tas ir, kārtība, kādā apakšizteiksmes ar vairākiem operatoriem tiek izpildītas. Piemēram, reizināšanas operatoram ir augstāka prioritāte, nekā saskaitīšanas operatoram, tāpēc izteiksme \texttt{2 + 3 * 4} tiek izskaitļota kā \texttt{2 + (3 * 4)}, nevis \texttt{(2 + 3) * 4}. 
Zemāk ir uzskaitīti operatori to prioritātes secībā, no augstākās uz zemāko. Operatori ar vienādu prioritāti tiek minēti kopīgi vienā saraksta apakšpunktā.

\begin{itemize}
  \item \texttt{!} (unārs negācijas operators)
  \item \texttt{*}, \texttt{/}, \texttt{\%} (aritmētiskie reizināšanas, dalīšanas un modula operatori)
  \item \texttt{+}, \texttt{-} (aritmētiskie saskaitīšanas un atņemšanas operatori)
  \item \texttt{>}, \texttt{<}, \texttt{>=}, \texttt{<=} (aritmētiskie salīdzināšanas operatori)
  \item \texttt{==}, \texttt{!=} (ekvivalences operatori)
  \item \texttt{\&\&} (konjukcija)
  \item \texttt{||} (disjunkcija) 
\end{itemize}

Ir kritiski atzīmēt, ka dažādu operatoru izpildes kārtību var mākslīgi paaugstināt, izmantojot apaļās iekavas. Izteiksmes iekavās tiek izpildītas pirmās, neatkarīgi no tajās esošo operatoru prioritātes.

Skaidrības labad, tiek dots piemērs ar saliktu izteiksmi un tās izvērtēšanas kārtību:
\begin{verbatim}
3 + 4 % 2 == 3 || true && false
\end{verbatim}

Alternatīvi, to var pārrakstīt ar iekavām, kas ilustrē izvērtēšanas kārtību:
\begin{verbatim}
((3 + (4 % 2)) == 3) || (true && false)
\end{verbatim}

Tātad, apakšizteiksme 
\begin{verbatim}
  ((3 + (4 % 2)) == 3)
\end{verbatim}
tiek izvērtēta pirmā (jo atrodas kreisajā pusē), kas rezultātā atgriež patiesu vērtību.
Pēc tam tiek izvērtēta otra apakšizteiksme
\begin{verbatim}  (true && false)
\end{verbatim}
kas arī atgriež patiesu vērtību. Beigās tiek pielietots disjunkcijas operators \texttt{||}, kas atgriež patiesu vērtību, jo vismaz viens no abiem operandiem (kas īstenībā ir izteiksmes) ir patiess.

\section{Izvērtēšanas kārtība}
Līdzīgi kā daudzās citās programmēšanas valodās, piemēram Java un Ruby, arī valodā Immutant izteiksmes izvērtēšanas kārtība ir no kreisās uz labo pusi. Tas nozīmē, ka izteiksmes kreisais operands tiek izvērtēts pirms labā operanda. 

Zemāk ir dots piemērs, kas ilustrē šo izvērtēšanas kārtību:

\begin{verbatim}
pure fn add(a, b) {
    return a + b;
}

imut sum = add(2, 3) + 4; // sum vērtība ir 9
\end{verbatim}

Dotajā piemēra mainīgajā (skat. \ref{section:vars}) \texttt{sum} tiek piešķirta vērtība, kas pēc būtības ir  izvērtēts izteiksmes \texttt{add(2, 3) + 4} rezultāts. Tā kā izteiksmes kreisais operands ir funkcijas izsaukums (skat. \ref{section:functions}) \texttt{add(2, 3)}, tad vispirms tiek izvērtēta šī apakšizteiksme, kas rezultātā atgriež skaitli \texttt{5}. Pēc tam tiek izvērtēts labais operands \texttt{4} (tas ir parasts skaitlis, tāpēc šeit netiek padarīts daudz darba), un beigās tiek pielietots saskaitīšanas operators \texttt{+}, kas atgriež summu \texttt{9}. Tātad, mainīgajam \texttt{sum} tiek piešķirta vērtība \texttt{9}.

\subsection{Saīsinātā izvērtēšana}

Interpretatora optimizācijas nolūkos, valodas specifikācijā ietilpst arī saīsinātās izvērtēšanas mehānisms, kas ļauj izvairīties no nevajadzīgu apakšizteiksmju izvērtēšanu, loģiskajās izteiksmēs ar disjunkciju \cite{short-circuit-logic}.

Pēc definīcijas, loģiskā izteiksme ar disjunkciju ir patiesa, ja vismaz viens no tās operandiem ir patiess.
Tā kā valodā Immutant izteiksmes tiek izvērtētas no kreisās puses uz labo, tad ir pietiekami izvērtēt tikai kreiso operandu, ja tas ir patiess.

Piemēram, izteiksmi \texttt{true || (someFunction() + 5 > 10)} izvērtē kā patiesu, pie tam interpretators ignorēs (neizvērtēs) labo operandu.

\section{Funkcijas}
\label{section:functions}

Funkcijas ir pilnībā vai daļēji izolēts program-kods, kas var tikt izsaukts un izmantots ar dažādiem parametriem, dažādās vietās un dažādos laika brīžos. Funkcijas pašas par sevi ir daļa no programmas koda, tomēr, lai tās varētu tikt izpildītas, ir nepieciešams tās izsaukt. 

Funkcijas definē sekojošā formā:
\begin{verbatim}
<purity> fn <identifier>(<parameters>) {
    <statements>
}
\end{verbatim}

<purity> apzīmē funkcijas īpašību mainīt datus ārpus tās konteksta. Datorzinātnēs \char"22
impure" jeb tulkojumā no angļu valodas "netīrs" apzīmē funkcijas, kas maina ārējos stāvokļus vai ir atkarīgas no tiem. Savukārt "pure" jeb "tīras" funkcijas ir tādas, kas neietekmē ārējos stāvokļus un ir atkarīgas tikai no to parametriem. Tīru funkciju izmantošana pirmkodā ir ieteicama, jo tā padara programmu prognozējamāku un vieglāk saprotamu, jo zināms ka tīras funkcijas var izsaukt tikai citas tīras funkcijas vai izteiksmes, kas nozīmē, ka tās nevienā brīdī neizmaina ārējo stāvokli. Tātad, \texttt{pure} atslēgvārds tiek lietots, lai definētu tīru funkciju, bet \texttt{impure} - netīru.

\subsection{Tīras un netīras funkcijas}

Ja funkcija ir definēta kā tīra, tad tās argumentu vērtības tiek padotas pēc to vērtībām. Tas nozīmē, ka, ja kāds arguments ir mainīgais, funckijā mainot tā vērtību, mainīgā vērtība mainīsies tikai funckijas ietvaros, bet ne citā apkārtnē. Citiem vārdiem, jebkurš mainīgais, kas padots kā arguments tīrai funkcija tiek pa jaunam deklarēts un inicializēts funkcijas iekšējā kontekstā.
Pie tam, tīras funkcijas ķermenī ir aizliegts izsaukt netīras funkcijas.

Savukārt netīras funkcijas argumenti tiek padoti kā atsauces uz to oriģinālajām vērtībām. Tas nozīmē, ka, ja kāds arguments ir mainīgais, funckijā mainot tā vērtību, mainīgā vērtība mainīsies arī ārējā kontekstā. Netīras funkcijas ķermenī ir atļauts izsaukt gan tīras, gan netīras funkcijas.

Atslēgvārda \texttt{pure} lietošana nav obligāta, jo valodā Immutant pēc noklusējuma lietotāja definētās funkcijas tiek uzskatītas par tīrām. 

\subsection{Funkcijas definīcija un izsaukums}

\begin{verbatim}
fn <identifier>(<parameters>) {
    <statements>
}
\end{verbatim}

Augstāk redzamajā piemērā funkcija tiek definēta kā tīra, jo nav lietots neviens no tīrības īpašības atslēgvārdiem. Atslēgvārds \texttt{fn} apzīmē, ka pēc tā seko funkcijas definīcija. <identifier> satur funkcijas nosaukumu, kas ir unikāls identifikators atmiņā. Uz funkcijas nosaukumu attiecas tie paši noteikumi, kas minēti sadaļā ~\ref{section:vars} par mainīgo identifikatoriem.

Pēc funkcijas nosaukuma seko apaļās iekavas, kas satur parametru sarakstu <parameters>. Parametri ir iekšējā funkcijas konteksta mainīgie, kas tiek nodoti funkcijai tās izsaukšanas brīdī, un kuru vērtības funkcija izmanto savā darbībā. Parametru saraksts ir komatu atdalītu parametru virkne. Ja funkcijai nav parametru, tad iekavas ir tukšas.

Funkcijas ķermenis <statements> ir ietverts figūriekavās, un satur apgalvojumus un izteiksmes, kas tiek izpildītas, kad funkcija tiek izsaukta. Funkcijas ķermenī ir jābūt vismaz vienam apgalvojumam vai izteiksmei. Ja funkcija ir tīra, tad tās ķermenī nav atļauts izsaukt netīras funkcijas vai veikt citas darbības, kas maina ārējo stāvokli.

Piemērs tīrai funkcijai, kas aprēķina divu skaitļu summu:
\begin{verbatim}
pure fn add(a, b) {
    return a + b;
}
\end{verbatim}

Piemērs netīrai funkcijai, kas pieskaita jaunu skaitli globālam mainīgajam:
\begin{verbatim}
mut num = 4;
impure fn addGlobal(newNum) {
    num += newNum;
}
\end{verbatim}

Funkcijas izsaukums ir izteiksme, kas satur funkcijas nosaukumu, kam seko apaļās iekavas ar argumentu sarakstu. Argumenti ir vērtības, kas tiek nodotas funkcijai tās izsaukšanas brīdī, un kuru vērtības funkcija izmanto savā darbībā. Argumentu saraksts ir komatu atdalītu argumentu virkne. Ja funkcijai nav argumentu, tad iekavas ir tukšas. Argumentus padod funkcijai secīgi, tādā pašā secībā kā tie ir definēti funkcijas parametru sarakstā. 

Piemērs funkcijas izsaukumiem:
\begin{verbatim}
addGlobal(5);
imut sum = add(3, 7);
\end{verbatim}

Pie nekorektas rīcības ar funkcijām parādās kāda no sekojošām izpildlaika kļūdām:
\begin{itemize}
  \item \texttt{RUNTIME\_ERR-8} 
  \item \texttt{RUNTIME\_ERR-13}
\end{itemize}

\subsection{Iebūvētas funkcijas}

Valodā Immutant ir definētas sekojošas iebūvētas funkcijas:
\begin{itemize}
  \item \texttt{print(value)} - izvada dotā operanda vērtību uz konsoli. pieņem jebkura datu tipa vērtību kā argumentu, un izvada tās reprezentāciju kā virkni uz konsoli.
  \item \texttt{time()} - izvada pašreizējo laiku milisekundēs kopš 1970. gada 1. janvāra 00:00:00 UTC.
  \item \texttt{toString(value), toNumber(value), toBoolean(value), typeOf(value)} - datu tipu konversijas funkcijas, kas aprakstītas sadaļā ~\ref{section:datatype-conversion}
  \item \texttt{input()} - nolasa lietotāja ievadi no standarta ievades kā virkni. Funkcija gaida, kamēr lietotājs ievada datus un nospiež Enter taustiņu, pēc tam atgriež ievadīto vērtību kā virkni.

\end{itemize}

\section{Kontroles plūsma}
Kontroles plūsma ir mehānisms, kas nosaka programmas izpildes secību. Valodā Immutant ir definēti sekojoši kontroles plūsmas mehānismi: \texttt{if-else} zarošanās un cikls \texttt{while}.

\subsection{Apgalvojums if-else}

Apgalvojums \texttt{if-else} ļauj izpildīt dažādas koda daļas atkarībā no nosacījuma izpildes. Sintakse ir sekojoša:
\begin{verbatim}
if (<condition>) {
    <statements>
} else {
    <statements>
}
\end{verbatim}

<condition> ir loģiska izteiksme, kas rezultātā atgriež patiesuma vērtību. Ja izteiksmes vērtība ir patiesa, tad tiek izpildīti apgalvojumi <statements> iekš pirmās figūriekavas. Ja izteiksmes vērtība ir aplama, tad tiek izpildīti apgalvojumi <statements> iekš otrās figūriekavas pēc atslēgvārda \texttt{else}.

Ja ir nepieciešams izpildīt vairākus nosacījumus, tad var izmantot vairākas \texttt{else/if} zarošanās. Sintakse ir sekojoša:
\begin{verbatim}
if (<condition1>) {
    <statements1>
} else {
    if (<condition2>) {
        <statements2>
    }
} else {
    <statements3>
}
\end{verbatim}

Pie tam, apgalvojums \texttt{else} nav obligāts, un to var izlaist, ja nav nepieciešams izpildīt kodu gadījumā, ja neviens no nosacījumiem nav izpildīts.

Piemērs programmai, kas atkarība no skaitļa vērtības izvada atbilstošu ziņojumu:
\begin{verbatim}
imut num = 10;

if (num > 0) {
    print("Number is greater than zero");
} else if (num < 0) {
    print("Number is less than zero");
} else {
    print("Number is zero");
}
\end{verbatim}

\subsection{Cikli}
Cikls \texttt{while} ļauj izpildīt koda daļu atkārtoti, kamēr nosacījums ir izpildīts. Sintakse ir sekojoša:
\begin{verbatim}
while (<condition>) {
    <statements>
}
\end{verbatim}

<condition> ir loģiska izteiksme, kas rezultātā atgriež patiesuma vērtību. Ja izteiksmes vērtība ir patiesa, tad tiek izpildīti apgalvojumi <statements> iekš figūriekavām. Pēc apgalvojumu izpildes, nosacījums tiek pārbaudīts vēlreiz, un ja tas joprojām ir patiess, tad apgalvojumi tiek izpildīti vēlreiz. Šis process turpinās, kamēr nosacījums kļūst aplams. Ja nosacījums sākotnēji ir aplams, tad cikla ķermenis netiek izpildīts ne reizi.

Ciklisku darbību var nodemonstrēt ar fibonacci skaitļu virknes ģenerēšanu:
\begin{verbatim}
// Demonstrē mainīgo izmantošanu ciklā
mut prev = 0;
mut curr = 1;
mut count = 0;
imut n = 10;

while (count < n) {
    imut val = curr;
    print(val);
    imut next = prev + curr;
    prev = curr;   
    curr = next;   
    count = count + 1;
}
\end{verbatim}

\section{Atslēgas vārdi}
\label{section:keywords}

Valodā Immutant ir definēti sekojoši atslēgas vārdi, kas ir rezervēti valodas sintaksei un tiem nevar tikt piešķirta cita nozīme:
\begin{itemize}
  \item \texttt{imut} - tiek lietots, lai deklarētu nemutablus mainīgos
  \item \texttt{mut} - tiek lietots, lai deklarētu mutablus mainīgos
  \item \texttt{fn} - tiek lietots, lai definētu funkcijas
  \item \texttt{pure} - tiek lietots, lai definētu tīras funkcijas
  \item \texttt{impure} - tiek lietots, lai definētu netīras funkcijas
  \item \texttt{if} - tiek lietots, lai definētu nosacījuma apgalvojumu
  \item \texttt{else} - tiek lietots, lai definētu nosacījuma apgalvojuma alternatīvu
  \item \texttt{while} - tiek lietots, lai definētu ciklu
  \item \texttt{return} - tiek lietots, lai atgrieztu vērtību no funkcijas
  \item \texttt{true} - patiesuma vērtība
  \item \texttt{false} - aplamas vērtība
\end{itemize}

\section{Formālā gramatika}
\label{section:grammar}

Valodas Immutant formālā, kas aprakstīta BNF formā, definē valodas specifikāciju - kas var izvērsties par kaut ko citu un uz ko tieši. Termināļi ir apzīmēti ar lielajiem burtiem, bet netermināļi ar mazajiem burtiem.

\begin{verbatim}
PROGRAMMA:
  program             -> statement* EOF

PRIEKŠRAKSTI:
  statement           -> var_declaration
                      | function_declaration
                      | if_statement
                      | while_statement
                      | return_statement
                      | block_statement
                      | expression_statement

  var_declaration     -> mutability IDENTIFIER 
                         ( "=" expression )? ";"
  
  mutability          -> "mut" | "imut"

  function_declaration -> purity? "fn" IDENTIFIER "(" 
                          parameters? ")" block_statement
  
  purity              -> "pure" | "impure"

  parameters          -> IDENTIFIER ( "," IDENTIFIER )*

  if_statement        -> "if" "(" expression ")" 
                         block_statement
                         ( "else" block_statement )?

  while_statement     -> "while" "(" expression ")" 
                         block_statement

  return_statement    -> "return" expression? ";"

  block_statement     -> "{" statement* "}"

  expression_statement -> expression ";"

IZTEIKSMES:
  expression          -> assignment

  assignment          -> logical_or 
                         ( "=" logical_or )?

  logical_or          -> logical_and 
                         ( "||" logical_and )*

  logical_and         -> equality 
                         ( "&&" equality )*

  equality            -> comparison 
                         ( ( "!=" | "==" ) comparison )*

  comparison          -> additive 
                         ( ( ">" | ">=" | "<" | "<=" ) 
                           additive )*

  additive            -> multiplicative 
                         ( ( "-" | "+" ) multiplicative )*

  multiplicative      -> unary 
                         ( ( "/" | "*" | "%" ) unary )*

  unary               -> ( "!" ) unary
                      | call

  call                -> primary ( "(" arguments? ")" )*

  arguments           -> expression ( "," expression )*

  primary             -> NUMBER
                      | STRING
                      | "true"
                      | "false"
                      | IDENTIFIER
                      | "(" expression ")"


\end{verbatim}

\noindent Apzīmējumu saraksts no formālās gramatikas:
\begin{itemize}
  \item \texttt{|} apzīmē alternatīvu (vai)
  \item \texttt{*} apzīmē nulli vai vairākas reizes (\textit{Kleene star})
  \item \texttt{?} apzīmē nulli vai vienreiz (opcionalitāte)
  \item \texttt{( )} apzīmē grupu
\end{itemize}

\chapter{Programmatūras Prasību specifikācija}
\label{chap:PPS}

\section{Funkcionālās prasības}

Interpretatora programmatūru iedala 5 moduļos, katrs no tiem atbild par savu funkcionalitāti. Skenēšanas, parsēšanas un izvērtēšanas moduļi veido pašu pamatu interpretēšanai, taču ir nepieciešami arī citi moduļi, lai nodrošinātu pilnvērtīgu programmu - lietotāja saskarnes modulis un interpretatora kodola modulis.

\renewcommand{\arraystretch}{2}
\begin{table}[h]
\centering
\begin{tabular}{p{5.5cm} p{7cm} c}
\toprule
\rowcolor{gray!60}
Modulis & Funkcija & Identifikators \\
\midrule

\multirow{2}{*}{Lietotāja saskarnes modulis}
    & Pirmkoda interpretēšana no datnes & CLI-1 \\
\cmidrule(lr){2-3}
    & REPL režīms & CLI-2 \\
\midrule

\multirow{1}{*}{Interpretatora kodola modulis}
    & Interpretēšanas piespiedu apstādināšana & CORE-1 \\

\midrule

\multirow{3}{*}{Skenēšanas modulis}
    & Rakstzīmju pārveidošana uz leksēmu zīmogiem & LEX-1 \\
\cmidrule(lr){2-3}
    & Burtciparu ne-virkņu vērtību skenēšana  & LEX-2 \\
\cmidrule(lr){2-3}
    & Literālo vērtību skenēšana & LEX-3 \\
  
\midrule

\multirow{2}{*}{Parsēšanas modulis}
    & Leksēmu parsēšana uz AST kokiem & PARSE-1 \\
\cmidrule(lr){2-3}
    & Parsētāja sinhronizēšana pēc notikušās parsēšanas kļūdas  & PARSE-2 \\
  
\midrule

\multirow{3}{*}{Izvērtēšanas modulis}
    & AST koka izvērtēšana & EVAL-1 \\
\cmidrule(lr){2-3}
    & Izteiksmes AST koka izvērtēšana & EVAL-2 \\
\cmidrule(lr){2-3}
    & Priekšraksta AST koka izvērtēšana & EVAL-3 \\
  
\midrule
\end{tabular}
\caption{Funkciju sadalījums pa moduļiem}
\end{table}


\begin{figure}[h]   
    \centering
  \includegraphics[scale=0.6]{assets/dataflow/dfd_lvl_1.jpg}
    \vspace{0.5cm}  
  \captionof{figure}{1. līmeņa datu plūsmas diagramma}
    \label{fig:dfd_lvl_1}                  
\end{figure}

\renewcommand{\arraystretch}{1.3}  % increase row height

\begin{longtable}{%
    >{\raggedright\arraybackslash}c
    >{\raggedright\arraybackslash}p{0.75\textwidth}
}
\toprule
\rowcolor{gray!20}
Paziņojuma identifikators & Paziņojuma apraksts \\
\midrule
SYNTAX\_ERR-1 & Ja skeneris sagaida virknes beigu simbolu, bet to neatrod, parāda paziņojumu: ``Unterminated string literal''. \\
\midrule
SYNTAX\_ERR-2 & Ja skaitlis neatbilst valodas specifikācijai, parāda paziņojumu: ``Invalid number''. \\
\midrule
SYNTAX\_ERR-3 & Ja skeneris neatpazīst leksēmas tipu, t.i., tā neeksistē valodas alfabētā, parāda paziņojumu: ``Invalid token: \texttt{<lexeme>}''. \texttt{<lexeme>} tiek aizstāts ar neatpazītās leksēmas vērtību. \\
\midrule
SYNTAX\_ERR-4 & Ja parsētājs neatrod atverošo iekavu nosacījuma izteiksmei, parāda paziņojumu: ``Expected '(' after \texttt{condition\_source}``. \texttt{<condition\_source>} ir nosacījuma izteiksmes lietotājs - \texttt{if} vai \texttt{while} priekšraksti. \\
\midrule
SYNTAX\_ERR-5 & Ja izteiksme ir grupēta iekavās vai ir daļa no nosacījuma un pēc tās neseko aizverošā iekava, parāda paziņojumu: ``Expected ')' after expression``. \\
\midrule
SYNTAX\_ERR-6 & Ja priekšraksta beigās nav atrodamas semikola zīmes, parāda paziņojumu: ``Expected ';' after \texttt{<expr\_type>}''. `<expr\_type>` ir vai nu \texttt{expression statement} vai \texttt{variable declaration} atkarībā no priekšraksta. \\
\midrule
SYNTAX\_ERR-7 & Ja priekšraksts ir bijis atverošais pirmkoda bloks, bet aizverošā figūriekava netika atrasta, tad parāda paziņojumu: ``Expected '\}' after block statement`` \\
\midrule
SYNTAX\_ERR-8  & Ja funkcijas izsaukumā padotais argumentu saraksts netiek noslēgts ar aizverošo iekavu, tad parāda paziņojumu: ``Expect ')' after arguments.``      \\
\midrule
SYNTAX\_ERR-9  & Ja parsētājs neatrod izteiksmi, kur tai būtu jābūt, parāda paziņojumu: ``Expected expression``.                                                     \\
\midrule
SYNTAX\_ERR-10 & Ja piešķiršanas operatora kreisas operands nav derīgs, lai izpildītu operāciju (nav lvalue), tad parāda paziņojumu: ``Invalid assignment target.``. \\
\midrule

RUNTIME\_ERR-1 & Ja dalīšanas operācijai padots dalītājs 0, tad parāda paziņojumu: ``Division by zero is illegal``.                                                                                                                                      \\

\midrule

RUNTIME\_ERR-2 & Ja lietotājs izmanto mainīgo vidē, kur tas nav deklarēts un neeksistē, tad parāda paziņojumu: ``Undefined variable: \textless{}t\textgreater{}``. \textless{}t\textgreater tiek aizvietots ar attiecīgā mainīgā nosaukumu.              \\
\midrule

RUNTIME\_ERR-3 & Ja operācijas operandu tipi neatbilst valodas specifikācijai, tad parāda paziņojumu ``Expected a \textless{}t\textgreater value``. \textless{}t\textgreater tiek aizvietots ar atbilstošu datu tipu, ko izvērtēšanas modulis sagaidīja. \\
\midrule

RUNTIME\_ERR-4 & Ja operatoram + abi operandi nav vienādā tipa un nav ne virknes ne skaitļu tipa, tad parāda paziņojumu: ``Operands to '+' must be both numbers or both strings``.                                                                       \\
\midrule
RUNTIME\_ERR-5 & Ja abi dalīšanas operācijas operandi nav skaitļi, izmet paziņojumu: ``Operands to '/' must be numbers``.                                                                                                                                \\
\midrule
RUNTIME\_ERR-6 & Ja funkcijas izsaukuma saucējs nav derīga funkcija, tad parāda paziņojumu: ``Callee is not a function``.                                                                                                                                \\
\midrule
RUNTIME\_ERR-7 & Ja mainīgais ar tādu pašu nosaukumu ir jau iepriekš deklarēts, parāda paziņojumu: ``Variable already defined: \textless{}t\textgreater{}``. \textless{}t\textgreater tiek aizstāts ar attiecīgu mainīgā nosaukumu.                      \\
\midrule
RUNTIME\_ERR-8 & Ja funkcija tiek izsaukta ar argumentu skaitu, kas atšķirās no parametru skaita funkcijas definīcijā, parāda paziņojumu: ``Incorrect number of arguments passed to function``.                                                          \\
\midrule

RUNTIME\_ERR-11 & Ja nemutablam mainīgam pēc inicializācijas vēlreiz piešķir kādu vērtību, parāda paziņojumu ``Cannot assign to constant variable: <t>``. <t> tiek aizstāts ar attiecīgu mainīgā nosaukumu.                                                                                  \\
\midrule
RUNTIME\_ERR-12 & Ja datus nav iespējam pārvērst uz citu datu tipu, parāda paziņojumu: ``Invalid type conversion``.                                                                                  \\\midrule
RUNTIME\_ERR-13 & Ja tīra funkcija izsauc netīru funkciju, parāda paziņojumu: ``Pure function cannot call impure function``.                                                                                  \\
\midrule
MISC\_ERR-1 & Ja doto failu neizdodas nolasīt, parāda paziņojumu: ``Error: Could not open file``.                                                                                              \\
\bottomrule
\caption{Kļūdu paziņojumu apraksts}
\end{longtable}

\section{Skenēšanas modulis}

Skenēšanas modulis ir atbildīgs par pirmkoda pārvēršanu leksēmās. Skenēšanas modulis izmanto leksisko analīzi, lai identificētu un grupētu pirmkoda elementus, piemēram, atslēgvārdus, operatorus, atomārās vērtības un identifikatorus.


\FloatBarrier

\begin{figure}[h]   
    \centering
    \includegraphics[scale=0.6]{assets/dataflow/dfd_lexer.jpg}  
    \vspace{0.3cm}  
    \caption{Skenēšanas moduļa 2.līmeņa DPD}
    \label{fig:dfd_lexer}                  
\end{figure}

\FloatBarrier

\renewcommand{\arraystretch}{1.7}

\begin{longtable}{%
  >{\raggedright\bfseries}p{0.25\textwidth}
  >{\raggedright\arraybackslash}p{0.65\textwidth}
  c
}
\toprule
\rowcolor{gray!20}
Identifikators: & LEX-1 & \\
\midrule
Nosaukums: & Rakstzīmju pārveidošana uz leksēmu zīmogiem & \\
\midrule
Mērķis: & Pārvērst pirmkodu leksēmās & \\
\midrule
Ievaddati: & Lietotāja pirmkods & \\
\midrule
Apstrāde: &
Skeneris dotajā secībā iziet cauri katram simbolam un pārvērš to atbilstošā leksēmā, veicot nepieciešamās papildfunkcijas pilnu leksēmu vērtību nolasīšanai, ja leksēma nesastāv tikai no vienas rakstzīmes. & \\
\midrule
Izvaddati: & Leksēmas un skenēšanas kļūdas, ja tādas radušās procesā. & \\
\midrule
\multirow{1}{*}{Kļūdu paziņojumi:} & SYNTAX\_ERR-1\\
\cmidrule(lr){2-3}
& SYNTAX\_ERR-2 \\
\cmidrule(lr){2-3}
& SYNTAX\_ERR-3 \\

\bottomrule
\caption{Funkcijas LEX-1 apraksts}
\end{longtable}
\vspace{0.8cm}

\renewcommand{\arraystretch}{1.7}

\begin{longtable}{%
  >{\raggedright\bfseries}p{0.25\textwidth}
  >{\raggedright\arraybackslash}p{0.65\textwidth}
  c
}
\toprule
\rowcolor{gray!20}
Identifikators: & LEX-2 & \\
\midrule
Nosaukums: & Literālo vērtību skenēšana & \\
\midrule
Mērķis: & Noskaidrot pilnas leksēmu vērtības kā literālus & \\
\midrule
Ievaddati: & Lietotāja pirmkods, leksēmas vērtības sākuma simbols, kas indicē, ka leksēma varētu būt noteikta tipa vērtība & \\
\midrule
Apstrāde: & Tiek noskaidrots vai leksēma var būt skaitlis vai virkne. Ja tas ir skaitlis, tad skeneris iteratīvi nolasa ciparu aiz ciparu, ļaujot vienam punkta simbolam atrasties šajā skaitlī, kas apzīmētu decimāldaļu. Virknes gadījuma skeneris noalasa visus simbolus sākot at atverošo un beidzot ar aizverošo pēdiņas simbolu. & \\
\midrule
Izvaddati: & Leksēmas pilna vērtība un skenēšanas kļūdas, ja tādas radušās procesā. & \\
\midrule
\multirow{1}{*}{Kļūdu paziņojumi:} & SYNTAX\_ERR-1\\
\cmidrule(lr){2-3}
& SYNTAX\_ERR-2 \\

\bottomrule
\caption{Funkcijas LEX-2 apraksts}
\end{longtable}
\vspace{0.8cm}

\renewcommand{\arraystretch}{1.7}

\begin{longtable}{%
  >{\raggedright\bfseries}p{0.25\textwidth}
  >{\raggedright\arraybackslash}p{0.65\textwidth}
  c
}
\toprule
\rowcolor{gray!20}
Identifikators: & LEX-3 & \\
\midrule
Nosaukums: & Burtciparu ne-virkņu vērtību skenēšana & \\
\midrule
Mērķis: & Noskaidrot vai dotā vērtība ir valodā rezervēts atslēgvārds vai lietotāja definēts identifikators & \\
\midrule
Ievaddati: & Lietotāja pirmkods, leksēmas vērtības sākuma simbols, kas indicē, ka leksēmai jābūt burtciparu ne-virknes vērtībai & \\
\midrule
Apstrāde: & Funkcija pārbauda, vai dotā vērtība neatbilst precīzi kādam no valodā rezervētiem atslēgvārdiem. Pretējā gadījumā tiek atgriezta informācija, ka leksēma ir lietotāja definēts identifikators. & \\
\midrule
Izvaddati: & Burtciparu ne-virkņu datu tips un vērtība & \\
\midrule
Kļūdu paziņojumi: & - \\

\bottomrule
\caption{Funkcijas LEX-3 apraksts}
\end{longtable}
\vspace{0.8cm}

\section{Parsēšanas modulis}

Parsēšanas modulis ir atbildīgs par leksēmu pārvēršanu abstraktā sintakses kokā (AST). Parsēšanas modulis izmanto sintaktisko analīzi, lai identificētu un strukturētu pirmkoda elementus, piemēram, izteiksmes, apgalvojumus un priekšrakstus.


\FloatBarrier

\begin{figure}[h]   
    \centering
    \includegraphics[scale=0.6]{assets/dataflow/dfd_parser.jpg}  
    \vspace{0.3cm}  
    \caption{Parsēšanas moduļa 2.līmeņa DPD}
    \label{fig:dfd_parser}                  
\end{figure}

\FloatBarrier

\renewcommand{\arraystretch}{1.7}

\begin{longtable}{%
  >{\raggedright\bfseries}p{0.25\textwidth}
  >{\raggedright\arraybackslash}p{0.65\textwidth}
  c
}
\toprule
\rowcolor{gray!20}
Identifikators: & PARSE-1 & \\
\midrule
Nosaukums: & Leksēmu parsēšana uz AST kokiem & \\
\midrule
Mērķis: & Pārvērst leksēmas abstraktā sintakses kokā (AST), lai pirmkoda izvērtēšana būtu iespējama & \\
\midrule
Ievaddati: & Leksēmas no lietotāja pirmkoda & \\
\midrule
Apstrāde: & Parsētājs izmanto rekursīvo nolaišanās algoritmu, parsējot leksēmas no gramatikas sākuma produkcijas līdz pat dziļākajai produkcijai, lai nodrošināti viennozīmīgu AST koka uzbūvi, respektējot uzdotās izteiksmju prioritātes. & \\
\midrule
Izvaddati: & AST koki un parsēšanas kļūdas, ja tādas radušās procesā. & \\
\midrule
\multirow{1}{*}{Kļūdu paziņojumi:} & SYNTAX\_ERR-4\\
\cmidrule(lr){2-3}
& SYNTAX\_ERR-5 \\
\cmidrule(lr){2-3}
& SYNTAX\_ERR-6 \\
\cmidrule(lr){2-3}
& SYNTAX\_ERR-7 \\
\cmidrule(lr){2-3}
& SYNTAX\_ERR-8 \\
\cmidrule(lr){2-3}
& SYNTAX\_ERR-9 \\
\cmidrule(lr){2-3}
& SYNTAX\_ERR-10 \\

\bottomrule
\caption{Funkcijas PARSE-1 apraksts}
\end{longtable}
\vspace{0.8cm}

\renewcommand{\arraystretch}{1.7}

\begin{longtable}{%
  >{\raggedright\bfseries}p{0.25\textwidth}
  >{\raggedright\arraybackslash}p{0.65\textwidth}
  c
}
\toprule
\rowcolor{gray!20}
Identifikators: & PARSE-2 & \\
\midrule
Nosaukums: & Parsētāja sinhronizēšana pēc notikušās parsēšanas kļūdas & \\
\midrule
Mērķis: & Parsēšanas kļūdas gadījumā nodot parsētājam informāciju, no kuras leksēmas ir jēgpilni atsākt parsēšanu. Tas tiek darīts, lai lietotājs uzzinātu pēc iespējams vairāk kļūdu, ko ir veicis pirmkoda sintaksē, bet taj pat laikā nodrošināt, ka turpmākā parsēšana nerada viltotus AST vai neloģiskas kļūdas. & \\
\midrule
Ievaddati: & Leksēmu masīvs un ziņa par pēdējo apstrādāto leksēmu & \\
\midrule
Apstrāde: & Funkcija iet pāri leksēmu masīvam, kamēr neatrod leksēmu, no kuras ir sagaidāms, ka sākas jauns priekšraksts, piemēram, mainīgā deklarācija. & \\
\midrule
Izvaddati: & Jauna pozīcija leksēmu masīvā, no kuras ir jēgpilni atsākt parsēšanu & \\
\midrule
Kļūdu paziņojumi: & - \\

\bottomrule
\caption{Funkcijas PARSE-2 apraksts}
\end{longtable}

\newpage
\section{Izvērtēšanas modulis}

Izvērtēšanas modulis ir atbildīgs par AST koku izvērtēšanu un programmas izpildi. Šis modulis ir pēdējais solis interpretācijas procesā, kur AST koks tiek pārvērsts par faktiskām darbībām un rezultātiem, kas atspoguļo lietotāja rakstītā pirmkoda ieceres.

\FloatBarrier

\begin{figure}[h]   
    \centering
    \includegraphics[scale=0.6]{assets/dataflow/dfd_eval.jpg}  
    \vspace{0.3cm}  
    \caption{Izvērtēšanas moduļa 2.līmeņa DPD}
    \label{fig:dfd_eval}                  
\end{figure}

\FloatBarrier

\renewcommand{\arraystretch}{1.7}

\begin{longtable}{%
  >{\raggedright\bfseries}p{0.25\textwidth}
  >{\raggedright\arraybackslash}p{0.65\textwidth}
  c
}
\toprule
\rowcolor{gray!20}
Identifikators: & EVAL-1 & \\
\midrule
Nosaukums: & AST koka izvērtēšana & \\
\midrule
Mērķis: & Izvērtēt AST koku un veikt darbības, kas atbilst lietotāja rakstītā pirmkoda loģikai un semantikai. & \\
\midrule
Ievaddati: & pirmkods noparsēts AST kokos & \\
\midrule
Apstrāde: & Funkcija novērtē, vai dotais AST koks atbilst priekšrakstam vai izteiksmei, un nodot kontroli atbilstošai apstrādes funkcijai.  & \\
\midrule
Izvaddati: & Izpildīts priekšraksta efekts, pēdējā izvērtētā vērtība no priekšraksta saturošām izteiksmēm & \\
\midrule
Kļūdu paziņojumi: & - \\

\bottomrule
\caption{Funkcijas EVAL-1 apraksts}
\end{longtable}
\vspace{0.8cm}

\renewcommand{\arraystretch}{1.7}

\begin{longtable}{%
  >{\raggedright\bfseries}p{0.25\textwidth}
  >{\raggedright\arraybackslash}p{0.65\textwidth}
  c
}
\toprule
\rowcolor{gray!20}
Identifikators: & EVAL-2 & \\
\midrule
Nosaukums: & Izteiksmes AST izvērtēšana & \\
\midrule
Mērķis: & Izvērtēt izteiksmes AST & \\
\midrule
Ievaddati: & Izteiksme AST formātā & \\
\midrule
Apstrāde: & Funkcija nosaka izteiksmes veidu un atbilstoši tam palaiž dotās izteiksmes izvērtēšanas algoritmu. & \\
\midrule
Izvaddati: & Izteiksmes vērtība, izpildīts efekts, ja tāds ir, piemēram, vērtības piešķiršana mainīgam & \\
\midrule
\multirow{1}{*}{Kļūdu paziņojumi:} & RUNTIME\_ERR-1\\
\cmidrule(lr){2-3}
& RUNTIME\_ERR-2 \\
\cmidrule(lr){2-3}
& RUNTIME\_ERR-3 \\
\cmidrule(lr){2-3}
& RUNTIME\_ERR-4 \\
\cmidrule(lr){2-3}
& RUNTIME\_ERR-5 \\
\cmidrule(lr){2-3}
& RUNTIME\_ERR-6 \\
\cmidrule(lr){2-3}
& RUNTIME\_ERR-7 \\
\cmidrule(lr){2-3}
& RUNTIME\_ERR-8 \\
\cmidrule(lr){2-3}
& RUNTIME\_ERR-11 \\
\cmidrule(lr){2-3}
& RUNTIME\_ERR-12 \\

\bottomrule
\caption{Funkcijas EVAL-2 apraksts}
\end{longtable}
\vspace{0.8cm}

\renewcommand{\arraystretch}{1.7}

\begin{longtable}{%
  >{\raggedright\bfseries}p{0.25\textwidth}
  >{\raggedright\arraybackslash}p{0.65\textwidth}
  c
}
\toprule
\rowcolor{gray!20}
Identifikators: & EVAL-3 & \\
\midrule
Nosaukums: & Priekšraksta AST izvērtēšana & \\
\midrule
Mērķis: & Izvērtēt priekšraksta AST & \\
\midrule
Ievaddati: & Priekšraksta AST koka izvērtēšana & \\
\midrule
Apstrāde: & Funkcija nosaka priekšraksta veidu un palaiž tam atbilstošu izvērtēšanas algoritmu. Tā kā priekšraksti sastāv no izteiksmēm, tas izmanto funkciju EVAL-2, lai sekmīgi izvērtētu visu priekšrakstu. & \\
\midrule
Izvaddati: & Izpildīts priekšraksta efekts, pēdējā izvērtētā vērtība no priekšraksta saturošām izteiksmēm & \\
\midrule
Kļūdu paziņojumi: & Funkcijas daļa, kas dara unikālu darbu, neveido nevienas kļūdas, tomēr iekšēji tā arī izmanto izteiksmju izvērtēšanu, tāpēc ši funkcijas realitātē rada visus paziņojumus no funkcijas EVAL-2 \\
\caption{Funkcijas EVAL-3 apraksts}
\end{longtable}



\section{Interpretatora kodola modulis}

Interpretatora kodols ir atbildīgs par interpretēšanas procesa kontroli un pārvaldību. Tas nodrošina, ka visi 3 interpretēšanas procesa moduļi (skenēšana, parsēšana un izvērtēšana) padot saražotos datus viens otram novērš šo citu moduļu darbību, ja citā interpretēšanas modulī ir notikusi kāda kļūda.


\begin{center}
\includegraphics[scale=0.7]{assets/dataflow/dfd_core.jpg}  
\captionof{figure}{Interpretatora kodola moduļa 2.līmeņa DPD}
\label{fig:dfd_core}
\end{center}
\vspace{0.5cm}

\renewcommand{\arraystretch}{1.7}

\begin{longtable}{%
  >{\raggedright\bfseries}p{0.25\textwidth}
  >{\raggedright\arraybackslash}p{0.65\textwidth}
  c
}
\toprule
\rowcolor{gray!20}
Identifikators: & CORE-1 & \\
\midrule
Nosaukums: & Interpretēšanas piespiedu apstādināšana & \\
\midrule
Mērķis: & Neļaut sekojošiem interpretēšanas procesa soļiem turpināties, ja kādā no moduļiem ir notikusi kļūda. Tas ir, nākamie soļi, piemēram, parsēšana vai izvērtēšana, ir bezjēdzīgi, ja dati, kas tiem tiktu padoti nav pilnvērtīgi. & \\
\midrule
Ievaddati: & Kļūdas no skenēšanas, parsēšanas vai izvērtēšanas moduļa & \\
\midrule
Apstrāde: & Funkcija izseko kļūdas katrā no moduļiem un novērš turpmāko soļu izpildi, ja tādas radušās. & \\
\midrule
Izvaddati: & Paziņojums par kļūdu un uz kuras rindiņas tā ir notikusi & \\
\midrule
Kļūdu paziņojumi: & - \\

\bottomrule
\caption{Funkcijas CORE-1 apraksts}
\end{longtable}

\section{Lietotāja saskarnes modulis}

Lietotāja saskarnes modulis ir atbildīgs par mijiedarbību starp lietotāju un interpretatoru. Tas nodrošina veidu, kā lietotājs var ievadīt pirmkodu un saņemt rezultātus vai kļūdu ziņojumus.

\begin{center}
\includegraphics[scale=0.6]{assets/dataflow/dfd_cli.jpg}  
\captionof{figure}{Lietotāja saskarnes moduļa 2.līmeņa DPD}
\label{fig:dfd_cli}
\end{center}
\vspace{0.5cm}

\renewcommand{\arraystretch}{1.7}

\begin{longtable}{%
  >{\raggedright\bfseries}p{0.25\textwidth}
  >{\raggedright\arraybackslash}p{0.65\textwidth}
  c
}
\toprule
\rowcolor{gray!20}
Identifikators: & CLI-1 & \\
\midrule
Nosaukums: & Pirmkoda interpretēšana no datnes & \\
\midrule
Mērķis: & Palaist interpretatoru ar pirmkodu no datnes & \\
\midrule
Ievaddati: & Datnes ceļš& \\
\midrule
Apstrāde: & Funkcija atver failu un nodot tās saturu interpretatora kodolam. Tas savukārt secīgi noskenē visas rindiņas un tikai tad nodot izveidotās leksēmas nākamajam interpretēšanas solim.  & \\
\midrule
Izvaddati: & Interpretēšanas rezultāts, kļūdas, ja tādas radījušās & \\
\midrule
Kļūdu paziņojumi: & MISC\_ERR-1 \\

\bottomrule
\caption{Funkcijas CLI-1 apraksts}
\end{longtable}
\vspace{0.8cm}


\begin{longtable}{%
  >{\raggedright\bfseries}p{0.25\textwidth}
  >{\raggedright\arraybackslash}p{0.65\textwidth}
  c
}
\toprule
\rowcolor{gray!20}
Identifikators: & CLI-2 & \\
\midrule
Nosaukums: & REPL režīms & \\
\midrule
Mērķis: & Nodrošināt interaktīvu pirmkoda interpretēšanas vidi & \\
\midrule
Ievaddati: & Viens vai vairāki (vienā blokā) pirmkoda priekšraksti & \\
\midrule
Apstrāde: & Ja ievadītā pirmkoda rindiņa ir izvērtējama viena pati, tad uzreiz nodod kontroli kodolam, kas veic skenēšanu, parsēšanu un izvērtēšanu tūlītēji. Tomēr, ja ievadītā rindiņa atver priekšrakstu bloku, funkcija uzkrāj pirmkodu buferī līdz lietotājs neaizver bloku. Gadījumā ar \texttt{if} priekšrakstu, funkcija pieprasa lietotājam turpināt ievadīt vēl pirmkodu un sagaida \texttt{else} bloku pirms sākas interpretēšana, jo \texttt{if} un \texttt{else} kalpo kā viens loģisks bloks. Ja priekšraksts \texttt{if} tiek aizvērts un seko tukša rindiņa, funkcija to uztver kā \texttt{if} priekšrakstu bez noklusējuma izpildes, tāpēc beidz pieprasīt ievaddatus un izvērtē priekšrakstu, ja vien tas neatrodas citā blokā, kura aizvēršana arī ir jāsagaida.  & \\
\midrule
Izvaddati: & Interpretēšanas rezultāts, kļūdas, ja tādas radījušās & \\
\midrule
Kļūdu paziņojumi: & - \\

\bottomrule
\caption{Funkcijas CLI-2 apraksts}
\end{longtable}

\section{Nefunkcionālās prasības}

\subsection{Veiktspēja}
Sistēmai ir jāspēj interpretēt pirmkodu ar vidējo ātrumu vismaz 1000 līnijas sekundē standarta mūsdienu datora konfigurācijā.

\subsection{Drošība}
Sistēma pēc būtības nevar garantēt, ka interpretējamās programmas kods nenodarīs kaitējumu sistēmai. Lietotājam ir jāapzinās šie risk un jāievēro piesardzība, interpretējot nezināmas izcelsmes pirmkodu.

\subsection{Uzturēšana}
Sistēmas kodam jābūt labi dokumentētam un strukturētam loģiskos moduļos, lai atvieglotu turpmāko uzturēšanu un attīstību. Ir jāveido vienības un integrācijas testi, lai nodrošinātu sistēmas stabilitāti un uzticamību pie veiktām izmaiņām.

\chapter{Programmatūras projektējuma apraksts}


\section{Daļējs funkciju projektējums}

\subsection{CLI-1 funkcijas projektējums: Pirmkoda interpretēšana no datnes}

Pirmkoda datnes ir primārais veids, kā viegli izplatīt lietojumprogrammas. Tas ļauj lietotājiem saglabāt un koplietot savu kodu, kā arī palaist to dažādās vidēs. Šī funkcija nodrošina interpretēšanas palaišanu tieši no pirmkoda datnes.

\begin{figure}[h]   
    \centering
    \includegraphics[scale=0.6]{assets/functions/fun_cli_1.jpg}  
    \vspace{0.5cm}  
    \caption{Funkcijas CLI-1 projektējums}
    \label{fig:fun_cli_1}                  
\end{figure}


\subsection{CLI-2 funkcijas projektējums: REPL režīms}

Dažkārt ir noderīgi ātri pārbaudīt nelielu koda fragmentu un eksperimentēt interaktīvā veidā - tam domāta REPL (Read-Eval-Print Loop) funkcija. Tā ļauj lietotājam ievadīt pirmkoda rindiņu, un uzreiz ieraudzīt rezultātu. 

\begin{center}
  \includegraphics[scale=0.6]{assets/functions/cli_2_repl-fun.jpg}
  \captionof{figure}{Funkcijas CLI-2 projektējums}
  \label{fig:fun_cli_2}
\end{center}

\subsection{LEX-1 funkcijas projektējums: Rakstzīmju pārveidošana uz leksēmu zīmogiem}

LEX-1 funkcija ir atbildīga par pirmkoda pārvēršanu leksēmās, kas ir interpretēšanas pamatvienības. Tā izskrien cauri katram simbolam pirmkodā un tās sasaista kopā ar meta informāciju - leksēmas tipu, vērtību un atrašanās vietu pirmkodā.

\begin{center}
  \includegraphics[scale=0.5]{assets/functions/lex-1-fun.jpg}
  \captionof{figure}{Funkcijas LEX-1 projektējums}
  \label{fig:fun_lex_1}
\end{center}


\subsection{PARSE-1 funkcijas projektējums: Leksēmu parsēšana uz AST kokiem}

PARSE-1 funkcija ir atbildīga par leksēmu pārvēršanu abstraktos sintakses kokos. Tā rekursīvi nolaižas cauri gramatikas produkcijām, ievērojot viennozīmību, un veidojot koku struktūru, kas atspoguļo pirmkoda loģiku un hierarhiju.

\begin{center}
  \includegraphics[scale=0.7]{assets/functions/fun_parse-1.jpg}
  \captionof{figure}{Funkcijas PARSE-1 projektējums}
  \label{fig:fun_parse_1}
\end{center}


\subsection{PARSE-2 funkcijas projektējums: Parsētāja sinhronizēšana pēc notikušās parsēšanas kļūdas}

PARSE-2 funkcija ir izstrādāta, lai nodrošinātu parsētāja stabilitāti un spēju turpināt darbu pēc parsēšanas kļūdas. Tā meklē piemērotu vietu leksēmu secībā, no kuras var atsākt parsēšanu, tādējādi ļaujot lietotājam uzzināt pēc iespējas vairāk kļūdu vienā interpretēšanas reizē.

\begin{center}
  \includegraphics[scale=0.7]{assets/functions/fun_parse-2.jpg}
  \captionof{figure}{Funkcijas PARSE-2 projektējums}
  \label{fig:fun_parse_2}
\end{center}

\subsection{EVAL-1 funkcijas projektējums: AST koka izvērtēšana}

EVAL-1 funkcija ir atbildīga par AST koka izvērtēšanu un, visbeidzot, programmas izpildi. Tā nosaka, vai dotais AST koks atbilst priekšrakstam vai izteiksmei, un nodod kontroli atbilstošai apstrādes funkcijai, lai veiktu nepieciešamās darbības.

\begin{center}
  \includegraphics[scale=0.8]{assets/functions/fun_eval-1.jpg}
  \captionof{figure}{Funkcijas EVAL-1 projektējums}
  \label{fig:fun_eval_1}
\end{center}

\chapter{Datu struktūras un algoritmi}

Šajā nodaļā tiek aprakstītas galvenās datu struktūras un algoritmi, kas izmantoti interpretatora implementācijā. Detalizēta izpratne par šīm struktūrām un algoritmiem ir būtiska sistēmas iekšējās darbības izpratnei.

\section{Datu struktūras}

\subsection{Vides struktūra (Environment)}




Vides datu struktūra tiek izmantota, lai glabātu mainīgo un funkciju vērtības izpildes laikā. Struktūra ir realizēta kā saistīts saraksts ar norādi uz vecāka vidi, lai atbalstītu leksisko tvērumu. Šeit vide un apkārtne tiek lietoti kā sinonīmi.

Leksiskais tvērums nozīmē, ka funkcijas var piekļūt mainīgajiem no tās vides, kurā tās tika definētas, nevis no vides, kurā tās tiek izsauktas. Tas ir būtiski funkciju darbībai un mainīgo redzamībai.

\begin{center}
  \includegraphics[scale=0.6]{assets/arch/env_structure.jpg}
  \captionof{figure}{Vides struktūra}
  \label{fig:env_structure}
\end{center}

\vspace{0.5cm}


Katrs apkārtnes mezgls satur norādi uz vecāka vidi (\texttt{parent}) un uz saistīto sarakstu ar mainīgajiem (\texttt{entries}). Kad tiek meklēts mainīgais, sistēma vispirms pārbauda pašreizējo vidi, un, ja mainīgais nav atrasts, meklē vecāka vidē rekursīvi līdz pat globālajai videi. Šī pieeja nodrošina leksisko tvērumu un ļauj iekšējām funkcijām piekļūt ārējo tvērumu mainīgajiem.

Visefektīvākais veids kā glabāt mainīgo vērtības ir izmantojot jaucējtabulu, kas nodrošina ātru piekļuvi pēc atslēgas (mainīgā nosaukuma). Neskatoties uz to, šajā interpretatorā ir izvēlēta saistīta saraksta pieeja, lai saglabātu vienkāršību un vieglāku implementāciju. To, protams, būtu ieteicams mainīt nākotnē.

\subsection{Abstraktā sintakses koka struktūras}

Abstraktais sintakses koks (AST) reprezentē programmas struktūru pēc parsēšanas. AST sastāv no divām galvenajām hierarhijām: izteiksmēm (Expr) un priekšrakstiem (Stmt).

\begin{verbatim}
Expr (pamata tips)
|-- LiteralExpr
|   |-- NumberExpr (double value)
|   |-- StringExpr (char* value)
|   +-- BoolExpr (int value)
|-- VariableExpr (char* name)
|-- AssignExpr (char* name, Expr* value)
|-- UnaryExpr (TokenType operator, Expr* operand)
|-- BinaryExpr (Expr* left, TokenType operator, Expr* right)
|-- LogicalExpr (Expr* left, TokenType operator, Expr* right)
+-- CallExpr (Expr* callee, Expr** arguments, size_t arg_count)

Stmt (pamata tips)
|-- ExprStmt (Expr* expression)
|-- VarDeclStmt (char* name, Expr* initializer, MutabilityType)
|-- FunDeclStmt (char* name, char** params, Stmt* body)
|-- ReturnStmt (Expr* value)
|-- IfStmt (Expr* condition, Stmt* then_branch, Stmt* else_branch)
|-- WhileStmt (Expr* condition, Stmt* body)
+-- BlockStmt (Stmt** statements, size_t count)
\end{verbatim}

Katrs mezgls satur \texttt{type} lauku, kas norāda mezgla tipu, un \texttt{line} lauku kļūdu ziņojumiem. Izteiksmju mezgli atgriež vērtības, bet priekšrakstu mezgli izpilda darbības un maina stāvokli. Šī struktūra ļauj rekursīvi apstrādāt programmas kodu, sākot no saknes mezgla un ejot dziļumā pa katru apakškoku.

\subsection{Vērtību reprezentācija}

Vērtības tiek reprezentētas ar \texttt{Value} struktūru, kas izmanto \texttt{union} efektīvai atmiņas izmantošanai. Katra vērtība satur tipu un atbilstošo datu lauku.

\begin{verbatim}
Value struktūra (32 baiti):
+-------------------------+
| ValueType type          | (4 baiti)
+-------------------------+
| union {                 | (16 baiti)
|   long double number;   |
|   int boolean;          |
|   char* string;         |
|   Callable* callable;   |
| }                       |
+-------------------------+
| MutabilityType mut      | (4 baiti)
| PurityType purity       | (4 baiti)
+-------------------------+

ValueType enum:
  VAL_NUMBER   - skaitliska vērtība (long double)
  VAL_BOOL     - būla vērtība (int)
  VAL_STRING   - vikrnes vērtība (char*)
  VAL_FN       - lietotāja definētā funkcija (Callable*)
  VAL_NATIVE   - iebūvēta funkcija (Callable*)
\end{verbatim}

Union konstrukcija ļauj vienā atmiņas vietā glabāt dažādus datu tipus, izmantojot tikai tik daudz atmiņas, cik nepieciešams lielākajam tipam. 

\section{Algoritmi}

\subsection{Leksiskā analīze}

Leksiskā analīze pārveido pirmkodu uz leksēmām, apstrādājot katru rakstzīmi un atpazīstot atslēgvārdus, identifikatorus, literāļus un operatorus.

\begin{verbatim}
Algoritms: scan_tokens(source_code)
  1. Inicializē token_buffer
  2. Kamēr nav sasniegts koda beigas:
     a. Izlaiž tukšumus un komentārus
     b. Nosaka nākamās leksēmas tipu:
        - Ja cipars -> skenē NUMBER
        - Ja burts -> skenē IDENTIFIER vai KEYWORD
        - Ja pēdiņa -> skenē STRING
        - Ja operators -> atpazīst (+ - * / = == != < > <= >=)
        - Ja pieturzīme -> atpazīst (; , ( ) { })
     c. Izveido Token{type, lexeme, line}
     d. Pievieno token_buffer
  3. Pievieno EOF leksēmu
  4. Atgriež token_buffer

Atslēgvārdu atpazīšana:
  - Pēc identifikatora nolasīšanas pārbauda, vai tas ir 
    atslēgvārds (imut, mut, fn, if, else, while, return)
  - Ja atbilst -> TOKEN_KEYWORD
  - Citādi -> TOKEN_IDENTIFIER
\end{verbatim}

\subsection{Parsēšana}
Parsēšana pārveido leksēmas uz AST kokiem, izmantojot rekursīvo nolaišanās metodi, ievērojot gramatikas noteikumus un operatoru prioritātes.

\begin{verbatim}
Algoritms: parse(tokens)
  1. Inicializē token_index = 0
  2. Izveido program_statements = []
  3. Kamēr nav sasniegtas programmas beigas:
     a. Parsē priekšrakstu un pievieno program_statements masīvam
  4. Atgriež BlockStmt{program_statements}

Algoritms: parse_statement()
  1. Nosaka nākamās leksēmas tipu:
     - Ja "imut" vai "mut" -> parse_var_declaration()
     - Ja "fn", "pure" vai "impure" -> parse_function_declaration()
     - Ja "if" -> parse_if_statement()
     - Ja "while" -> parse_while_statement()
     - Ja "{" -> parse_block_statement()
     - Ja "return" -> parse_return_statement()
     - Citādi -> parse_expression_statement()

Algoritms: parse_expression()
  Izmanto operatoru prioritātes (no zemākās uz augstāko):
  - parse_or_expression()
    +- parse_and_expression()
       +- parse_equality_expression()
          +- parse_comparison_expression()
             +- parse_additive_expression()
                +- parse_multiplicative_expression()
                   +- parse_unary_expression()
                      +- parse_call_expression()
                         +- parse_primary_expression()

Algoritms: parse_or_expression()
  1. Parsē left = parse_and_expression()
  2. Kamēr nākamā leksēma ir "||":
     a. patērē "||"
     b. Parsē right = parse_and_expression()
     c. left = LogicalExpr{left, OR, right}
  3. Atgriež left

Algoritms: parse_and_expression()
  Identisks parse_or_expression(), bet ar "&&" operatoru

Algoritms: parse_equality_expression()
  1. Parsē left = parse_comparison_expression()
  2. Kamēr nākamā leksēma ir "==" vai "!=":
     a. Operators = nākamā leksēma
     b. patērē operatoru
     c. Parsē right = parse_comparison_expression()
     d. left = BinaryExpr{left, operators, right}
  3. Atgriež left

Algoritms: parse_comparison_expression()
  1. Parsē left = parse_additive_expression()
  2. Kamēr nākamā leksēma ir "<", ">", "<=", ">=":
     a. Operators = nākamā leksēma
     b. patērē operatoru
     c. Parsē right = parse_additive_expression()
     d. left = BinaryExpr{left, operators, right}
  3. Atgriež left

Algoritms: parse_additive_expression()
  1. Parsē left = parse_multiplicative_expression()
  2. Kamēr nākamā leksēma ir "+" vai "-":
     a. Operators = nākamā leksēma
     b. patērē operatoru
     c. Parsē right = parse_multiplicative_expression()
     d. left = BinaryExpr{left, operators, right}
  3. Atgriež left

Algoritms: parse_multiplicative_expression()
  1. Parsē left = parse_unary_expression()
  2. Kamēr nākamā leksēma ir "*", "/" vai "%":
     a. Operators = nākamā leksēma
     b. patērē operatoru
     c. Parsē right = parse_unary_expression()
     d. left = BinaryExpr{left, operators, right}
  3. Atgriež left

Algoritms: parse_unary_expression()
  1. Ja nākamā leksēma ir "!":
     a. patērē "!"
     b. Parsē operand = parse_unary_expression()
     c. Atgriež UnaryExpr{NOT, operand}
  2. Citādi parsē call_expression()

Algoritms: parse_call_expression()
  1. Parsē expr = parse_primary_expression()
  2. Kamēr nākamā leksēma ir "(":
     a. patērē "("
     b. Parsē argumentu sarakstu un tos pievieno arguments masīvam:
        - arguments = []
     c. Ja nākamā leksēma nav ")":
        - arguments += parse_expression()
        - Kamēr nākamā leksēma ir ",":
          * patērē ","
          * arguments += parse_expression()
     d. patērē ")"
     e. expr = CallExpr{expr, arguments}
  3. Atgriež expr

Algoritms: parse_primary_expression()
  1. Nosaka nākamās leksēmas tipu:
     - Ja NUMBER -> Atgriež NumberExpr{value}
     - Ja STRING -> Atgriež StringExpr{value}
     - Ja "true" -> Atgriež BoolExpr{true}
     - Ja "false" -> Atgriež BoolExpr{false}
     - Ja IDENTIFIER -> Parsē variable_or_assignment()
     - Ja "(" -> parse_grouped_expression()
\end{verbatim}

Parsēšana rekursīvi nolaižas cauri izteiksmju hierarhijai, ievērojot operatoru prioritātes. Katra funkcija atbild par vienu prioritātes līmeni, sākot no zemākās (loģiskie operatori) līdz augstākajai (primāras izteiksmes). Rekursīvā nolaišanās nodrošina pareizu asociativitāti. Ja parsēšana neizdodas, tiek izvirzīta sistēmas kļūda ar norādi uz leksēmas pozīciju pirmkodā.

\subsection{Izvērtēšana}

Izvērtēšana pārveido AST kokus par izpildlaika darbībām, izmantojot koka apstaigāšanas interpretācijas metodi. Katra AST mezgla veids tiek apstrādāts atbilstošā veidā, un mainīgo vērtības tiek uzglabātas vidē.

\begin{verbatim}
Algoritms: evaluate(ast, environment)
  1. Inicializē context{environment, error_flag}
  2. Izvērtē ast root mezglu
  3. Ja kļūda flags ir uzstādīta, atgriež null
  4. Citādi atgriež pēdējo izvērtēto vērtību

Algoritms: eval_statement(stmt, context)
  1. Nosaka priekšraksta tipu:
     - Ja ExprStmt -> Izvērtē izteiksmi
     - Ja VarDeclStmt -> Deklarē mainīgo vidē
     - Ja FunDeclStmt -> Reģistrē funkciju vidē
     - Ja BlockStmt -> Izveido jaunu vidi un izvērtē bloku
     - Ja IfStmt -> Novērtē nosacījumu, izpilda attiecīgo zaru
     - Ja WhileStmt -> Atkārtoti izpilda, kamēr nosacījums ir patiess
     - Ja ReturnStmt -> Nostāda return_value un iziet

Algoritms: eval_expression(expr, context)
  1. Nosaka izteiksmes tipu:
     - Ja Literal -> Atgriež vērtību
     - Ja Variable -> Meklē mainīgo vidē, atgriež vērtību
     - Ja Assign -> Izvērtē izteiksmi, atjaunina mainīgā vērtību vidē
     - Ja Binary -> Izvērtē abus operandus, pielieto operatoru
     - Ja Logical -> Izvērtē loģisko izteiksmi, ņemot vērā loģisko saīsināšanu
     - Ja Unary -> Izvērtē operandu, pielieto operatoru
     - Ja Call -> Izvērtē saucēju un argumentus, izsauc funkciju

Algoritms: eval_block(statements, context)
  1. Izveido jaunu apkārtni new_env{parent: context.env}
  2. Priekš katra priekšraksta s in statements:
     a. eval_statement(s, new_context)
     b. Ja return_value ir uzstādīts, iziet
     c. Ja kļūdas karogs ir uzstādīts, iziet

Algoritms: eval_call_expr(callee_expr, arguments, context)
  1. Izvērtē funkciju function = eval_expression(callee_expr, context)
  2. Pārbauda, vai function ir callable tipa
  3. Pārbauda argumentu skaitu
  4. Priekš noteikta callable tipa:
     a. Ja VAL_FN:
        - Izveido call_env{parent: function.closure_env}
        - Izveido parametru mainīgos ar argumentu vērtībām iekš call_env apkārtnes
        - Izpilda funkcijas ķermeni ar iekš call_env apkārtnes
        - Atgriež return_value
     b. Ja VAL_NATIVE:
        - Izsauc C funkciju ar arguments
        - Atgriež rezultātu

Algoritms: lookup_variable(name, env)
  1. current_env = env
  2. Kamēr current_env != null:
     a. Meklē mainīgā nosaukumu name current_env.entries sarakstā
     b. Ja atrasts, atgriež entry.value
     c. current_env = current_env.parent
  3. Ja nav atrasts, atgriež kļūdu RUNTIME_ERR-2

Algoritms: apply_binary_operator(left, op, right)
  1. Pēc operatora tipa pārbauda operandu tipus
  2. Ja aritmētiskais operators:
     - Abiem operandiem jābūt NUMBER
     - Atgriež skaitlisku rezultātu
  3. Ja salīdzinājuma operators:
     - Abiem operandiem jābūt NUMBER
     - Atgriež BOOL rezultātu
  4. Ja vienādības operators:
     - Abiem operandu tipiem ir jāsakrīt
     - Atgriež BOOL rezultātu
\end{verbatim}

Mainīgo un funkciju vērtības tiek uzglabātas vidē, kas tiek dinamiski izveidota pie katra funkcijas izsaukuma. Videi ir norāde uz vecāka apkārtni, kas ļauj iedarbināt leksisko tvērumu, kur iekšējās vides var piekļūt ārējo apkārtņu mainīgajiem. Kļūdas tiek pamanītas katrā posmā, un ja kļūda ir konstatēta, interpretācija apstājas.

\chapter{Testēšana}
\section{Testēšanas dokumentācija}

\renewcommand{\arraystretch}{1.15}
\setlength{\tabcolsep}{4pt}

\begin{longtable}{|
>{\raggedright\arraybackslash}p{1.7cm}|
>{\raggedright\arraybackslash}p{1.5cm}|
>{\raggedright\arraybackslash}p{6.0cm}|
>{\raggedright\arraybackslash}p{3.8cm}|
>{\centering\arraybackslash}p{1.9cm}|}
\hline

\hline
\rowcolor{gray!40}
\textbf{Funkcijas identifikators} &
\textbf{Testēšanas datums} &
\textbf{Soļi} &
\textbf{Sagaidāmais rezultāts} &
\textbf{Testa rezultāts} \\
\hline
\endhead

LEX-1 & 19.12 &
1.~ Izveido pirmkoda virkni "3 + @ - \$()" \newline
2.~Skenē doto pirmkoda virkni\newline
& leksēmas NUMBER(3), PLUS, MINUS, LEFT\_PAREN, RIGHT\_PAREN \newline 2 kļūdainas leksēmas & OK \\ \hline

LEX-1 & 19.12 &
1.~ Izveido pirmkoda virkni "\&\&" \newline
2.~Skenē doto pirmkoda virni\newline
& Loģiskā tipa leksēma "\&\&" \newline 2 kļūdainas leksēmas & OK \\ \hline

LEX-2 & 15.12 &
1.~Izveido virkni ``else`` \newline
2.~Skenē izveidoto virkni \newline
& Atslēgvārda tipa leksēma ar vērtību ``else`` & FAIL \\ \cline{2-2} \cline{5-5}
& 17.12 & & & OK \\ \hline

LEX-2 & 15.12 &
1.~Izveido virkni "39.456723asd=as" \newline
2.~Skenē izveidoto virkni \newline
& Skaitļiskā tipa leksēma ar vērtību "39.456723" & OK \\ \hline

LEX-3 & 15.12 &
1.~Izveido virkni "\_immutant" \newline
2.~Skenē izveidoto virkni \newline
& Identifikatora tipa leksēma ar vērtību "\_immutant" & OK \\ \hline


PARSE-1 & 18.12 &
1. Izveido aritmētisku izteiksmi ar leksēmām: 2, +, 4, /, 5\newline
2.~Izsauc parsētāju ar dotām leksēmām\newline
3.~Pārbauda AST koka formu
& BinaryExpr(+) [NUMBER(2), BinaryExpr(/) [NUMBER(4), NUMBER(5)]]
& OK \\ \hline

PARSE-1 & 27.12 &
1.~Parsē binārās izteiksmes ar dažādiem operatoriem\newline
2.~Pārbauda, ka operāciju kārtība tiek ievērota\newline
3.~Pārbauda AST struktūru
& BinaryExpr(-) [BinaryExpr(+) [NUMBER(1), BinaryExpr(*) [NUMBER(2), NUMBER(3)]], NUMBER(4)]
& FAIL \\ \cline{2-2} \cline{5-5}
& 28.12 & & & FAIL \\ \cline{2-2} \cline{5-5}
& 30.12 & & & OK \\ \hline

PARSE-1 & 02.01 &
1.~Parsē priekšraksta bloku no leksēmām: \{, \}\newline
& Izvedots pirmkoda bloka AST mezgls ar 0 priekšrakstiem & OK  \\ \hline

EVAL-2 & 18.12 &
1.~Saskaita virknes: ``from the '' + ``outside world''   \newline
2.~Izvērtē izteiksmes vērtību\newline
& virkne ``from the outside world'' & OK \\ \hline

EVAL-2 & 22.12 &
1.~Izvērtē aritmētiskās operācijas: 10 + 32.5\newline
2.~Pārbauda rezultāta vērtību un tipu\newline
& Skaitliskā vērtība 42.5 & OK \\ \hline

EVAL-2 & 28.12 &
1.~Izvērtē atņemšanas operāciju: -100 - 58.5\newline
2.~Pārbauda rezultāta vērtību\newline
& Skaitliskā vērtība -158.5 & OK \\ \hline

EVAL-2 & 30.12 &
1.~Izvērtē reizināšanas operāciju: 6 * 7\newline
2.~Pārbauda rezultāta vērtību\newline
& Skaitliskā vērtība 42 & OK \\ \hline

EVAL-2 & 29.12 &
1.~Izvērtē dalīšanas operāciju: 84 / 2\newline
2.~Pārbauda rezultāta vērtību\newline
& Skaitliskā vērtība 42 & OK \\ \cline{2-2} \cline{5-5}
& 01.01 & & & FAIL \\ \cline{2-2} \cline{5-5}
& 02.01 & & & OK \\ \hline

EVAL-2 & 03.01 &
1.~Mēģina dalīt ar nulli: 42 / 0\newline
2.~Pārbauda kļūdas stāvokli\newline
& Kļūda RUNTIME\_ERR-1 & OK \\ \hline

EVAL-2 & 02.01 &
1.~Piešķir mainīgajam x vērtību 42\newline
2.~Pārbauda, ka vērtība tiek saglabāta vidē\newline
& Mainīgā x vērtība ir 42 & OK \\ \hline

EVAL-2 & 03.01 &
1.~Mēģina piešķirt vērtību nedefinētam mainīgajam y\newline
2.~Pārbauda kļūdas stāvokli\newline
& Kļūda RUNTIME\_ERR-2 & OK \\ \hline

EVAL-3 & 18.12 &
1.~Izvērtē IF/ELSE izteiksmi ar patieso nosacījumu\newline
2.~Pārbauda, ka izpildās THEN bloks\newline
3.~Pārbauda, ka ELSE bloks netiek izpildīts
& IF bloks izpildīts, ELSE netiek & OK \\ \cline{2-2} \cline{5-5}
& 20.12 & & & OK \\ \hline

EVAL-3 & 26.12 &
1.~Izvērtē WHILE ciklu ar nosacījumu, kurš kļūst aplams pēc 3 iterācijām\newline
2.~Pārbauda, ka bloks izpildās 3 reizes\newline
3.~Apstiprina pareizu cikla apstāšanos
& Cikls izpildās 3 reizes, pēc tam apstājas & FAIL \\ \cline{2-2} \cline{5-5}
& 28.12 & & & OK \\ \hline

EVAL-3 & 03.01 &
1.~Izvērtē funkciju izsaukumu ar nepareizu argumentu skaitu\newline
2.~Funkcija sagaida 2 argumentus, bet tiek padots 1\newline
3.~Pārbauda kļūdas kodu
& Kļūda RUNTIME\_ERR-8 & OK \\ \hline


\end{longtable}

\renewcommand{\arraystretch}{1.0}



\chapter{Projekta Organizācija}
Vispirms tika izstrādāta pilna valodas specifikācija un tad sākta programmatūras izstrāde, kas tika veikta individuāli. Kvalifikācijas darba tēmas izvēlē bija tīri no personīgās iniciatīvas. Programmatūras pirmkods ir rakstīts valodā C pēc C11 standarta, izmantojot GNU Compiler Collection (GCC) kompilatoru. 

Koda testēšana notika vienlaicīgi ar galvenās programmatūras izstrādi, nodrošinot modulāru arhitektūru un plašu testu klāstu. 
Pilns kvalifikācijas darba dokuments ir sagatavots pēc programmatūras izstrādes un testēšanas pabeigšanas.

\chapter {Kvalitātes nodrošināšana}
Programmatūras kvalitātes nodrošināšanai lielāko uzsvaru tika likts uz vienībtestēšanu un integrācijas testēšanu. Katrs izstrādātais modulis tika pārbaudīts, lai nodrošinātu tā atbilstību specifikācijai un pareizu darbību dažādos scenārijos. Testēšanas rezultāti tika dokumentēti, un visi atklātie defekti tika novērsti pirms galīgās programmatūras versijas izveides.

Lai programmpirmkods pats par sevi būtu kvalitatīvs, tika ievērotas labās programmšanas prakses, piemēram, koda lasāmības uzturēšana, komentāru rakstīšana un modulāru funkciju izstrāde. Izmantotā valoda C ir stingri tipizēta, kas palīdz novērst daudzas potenciālās kļūdas jau kompilācijas laikā. Lai paātrinātu izstrādes procesu, tika izmantota LSP (Language Server Protocol) integrācija iekš koda redaktora, kas nodrošināja automātisku koda formatēšanu un sintakses pārbaudi vēl pirms kompilatora palaišanas.

Programmatūras dokumentācija tika izstrādāta, balstoties uz LVS 72:1996 un LVS 68:1996 vadlīnijām. Lai nodrošinātu lietotājam noderīgu programmatūru, interpretatora izstrādes laikā tika veikta UAT testēšana, pārbaudot izstrādāto moduļu lietderību reālos scenārijos, kas veicināja prasību pielāgošanu lietotāja vajadzībām. Akcepttestēšanas grupa sastāv tikai no paša autora un darba vadītāja.

Papildus manuālai vienībtestu un integrācijas testu palaišanai, tika izveidota automatizēta testēšanas sistēma, izmantojot GitHub Actions, kas mākonī palaida visu testu izpildi, katru reizi, kad tiešsaistes repozitorijs tika atjaunināts. Tas nodrošināja, ka jaunie labojumi vai jaunizveidotās funkcijas neietekmē jau esošo funkcionalitāti neparedzamā veidā.

\chapter{Konfigurācijas pārvaldība}

Porgrammatūras un tās dokumentācijas pirmkods ir versionēti, izmantojot Git versiju kontroles sistēmu. Versiju kontrolei ir piesaistīts tiešsaistes repozitorijs GitHub platformā, kur drošā veidā tiek glabātas visas izmaiņas un versijas. Katrs izstrādes posms ir dokumentēts ar atbilstošiem komentāriem un izmaiņu aprakstiem, kas ļauj viegli izsekot izmaiņām un atgriezties pie iepriekšējām versijām, ja nepieciešams.

Porgrammas kompilācijas un testēšanas rīka konfigurācijas ir definētas katra savā failā (Makefile un project.yml attiecīgi), kas arī ir glabāti versiju kontroles sistēmā. 

\chapter{Darbietilpības novērtējums}

% create me a table hat spans full opage widht and has 5 columns, also header and footer rows need to be gray and bold

\label{tab:work-estimation}
\begin{longtable}{|>{\raggedright\arraybackslash}p{0.25\textwidth}|>{\centering\arraybackslash}p{0.17\textwidth}|>{\centering\arraybackslash}p{0.17\textwidth}|>{\centering\arraybackslash}p{0.17\textwidth}|>{\centering\arraybackslash}p{0.16\textwidth}|}
\hline
\rowcolor{gray!40}
\textbf{Darba uzdevums} & \textbf{Optimistiskais laiks (dienas)} & \textbf{Reālistiskais laiks (dienas)} & \textbf{Pesimistiskais laiks (dienas)} & \textbf{Faktiskais laiks (dienas)} \\
\hline
Prasību ievākšana un valodas specifikācijas sastādīšana & 7 & 14 & 18 & 15 \\
\hline
Kompilatoru teorijas un testēšanas rīka izmantošanas apgūšana & 10 & 13 & 20 & 13 \\
\hline
Interpretatora kodola izstrāde & 20 & 25 & 35 & 20 \\
\hline
Lietotāja saskarnes izstrāde un kodola integrācija & 4 & 6 & 8 & 4 \\
\hline
Testēšana un kļūdu novēršana & 8 & 12 & 15 & 12 \\
\hline
Kopā & 49 & 70 & 96 & 64 \\
\hline
\caption{Darbietilpības novērtējums}
\end{longtable}

Vadoties pēc \ref{tab:work-estimation} tabulas, var secināt, ka kopējais faktiskais darba laiks bija 64 dienas, kas ir pārspēj pat reālistisko laika novērtējumu 70 dienas. Tas liecina par efektīvu laika plānošanu un izpildi projekta gaitā.

Tā kā viena mēneša ietvaros ir aptuveni 21 darba diena, tad kopējais projekta izstrādes laiks ir aptuveni 3 mēneši.

Lielāko daļu laika aizņēma prasību ievākšana un valodas specifikācijas sastādīšana, kā arī interpretatora kodola izstrāde. Šie posmi bija kritiski projekta veiksmīgai īstenošanai, un tiem tika pievērsta īpaša uzmanība, lai nodrošinātu augstu kvalitāti un atbilstību lietotāja vajadzībām. Proti, kompilatoru teorijas un testēšanas rīka izmantošanas apgūšana aizkavēja projekta izstrādi, taču bez šīm zināšanām nebūtu iespējams izstrādāt interpretatoru prātīgā laikā, tāpēc šis projekta posms nav mazāk svarīgs par pārējiem.

\chapter{Secinājumi}

Šajā kvalifikācijas darbā tika izstrādāts vienkāršs interpretators imperatīvai programmēšanas valodai, kas atbalsta pamata datu tipus, mainīgos, izteiksmes, priekšrakstus un funkcijas. Interpretators tika izstrādāts, izmantojot modulāru pieeju, sadalot to skenēšanas, parsēšanas un izvērtēšanas moduļos, kas ļauj viegli uzturēt un paplašināt programmatūru nākotnē.

Jaunizveidotā valoda ir radīta ar mērķi popularizēt konstantu datu plūsmu caur programmatūru, kas tiek panākts ar tīru funkciju un nemutablo mainīgo izmantošanu. Akcepttēstēšana parādīja, ka arī bez mutablu mainīgo un netīru funkciju izmantošanas ir ļoti sarežģīti vai par dažreizi neiespējami izveidot noteiktus algoritmus, piemēram, Fibonacci skaitļu virknes ģenērēšanu. Tas pierāda, ka valodas specifikācija arī ir veiksmīgi sasniegusi savu mērķi, jo lietotājam ir dotas visas galvenās programmēšanas konstrukcijas, lai varētu izveidot funkcionālu programmu, vienlaicīgi liekot lietotājam domāt par to, kā viņa kods varētu tikt uzlabots, lai tas būtu uzturamāks un efektīvāks.

Tā kā Immutant valodas sākotnējā versija (aprakstīta šajā dokumentā) nav tik bagātīga kā citas populāras programmēšanas valodas, tai ir daudz iespējas tālāk attīstīties. Viena no šādām iespējām ir paplašināt valodas sintaksi un semantiku, pievienojot jaunas datu struktūras, piemēram, masīvus vai vārdnīcas, kā arī paplašināt esošo funkciju klāstu ar jauniem iebūvētiem rīkiem. Vēl viena iespēja ir uzlabot veiktspēju, izstrādājot interpretatora virtuālo mašīnu un īstenojot optimizācijas paņēmienus, piemēram, neizmantotās atmiņas automātisko atbrīvošanu vai izteiksmju priekšapstrādi.


\nocite{crafting-interpreters}
\bibliographystyle{plain}
\bibliography{references}   

\clearpage
\thispagestyle{empty}

\noindent Kvalifikācijas darbs \textbf{Interpretators programmēšanas valodai Immutant} izstrādāts Latvijas Universitātes Eksakto zinātņu un tehnoloģiju fakultātē, Datorikas nodaļā.

\vspace{1.2cm}
\noindent Ar savu parakstu apliecinu, ka darbs izstrādāts patstāvīgi, izmantoti tikai tajā norādītie informācijas avoti un iesniegtā darba elektroniskā kopija atbilst izdrukai un/vai recenzentam uzrādītajai darba versijai.

\vspace{2.0cm}
\noindent Autors: \textbf{\textit{Rolands Frīdemanis}} \rule{6cm}{0.4pt} \hspace{0.6cm}\textbf{\underline{\hspace{1.2cm}}.01.2026.}

\vspace{2.0cm}
\noindent Rekomendēju darbu aizstāvēšanai\\
Darba vadītājs: \textbf{\textit{Dr. dat. Aleksandrs Belovs}} \rule{6cm}{0.4pt} \hspace{0.6cm}\textbf{\underline{\hspace{1.2cm}}.01.2026.}

\vspace{2.0cm}
\noindent Recenzents: \textbf{\textit{Dr. dat. 
Zane Bičevska}}

\vspace{2.5cm}
\noindent Darbs iesniegts \textbf{05.01.2026.}\\
Kvalifikācijas darbu pārbaudījumu komisijas sekretārs (elektronisks paraksts)



\end{document}