\documentclass[12pt,a4paper]{report}

\usepackage{formatting}
\usepackage{tabularx}
\usepackage{cite}  % optional, improves formatting
\usepackage{graphicx}
\usepackage{multirow}
\usepackage{booktabs}
\usepackage[table]{xcolor}
\usepackage{placeins}
\usepackage{longtable}
\usepackage{caption}

\title{LATVIJAS UNIVERSITĀTE
EKSAKTO ZINĀTŅU UN TEHNOLOĢIJU FAKULTĀTE}

\author{Rolands Frīdemanis}


\begin{document}

\begin{titlepage}
    \centering
    
    {\Large LATVIJAS UNIVERSITĀTES\\EKSAKTO ZINĀTŅU UN TEHNOLOĢIJU FAKULTĀTES DATORIKAS NODAĻA\\[5cm]}
    
    {\LARGE \textbf{ INTERPRETATORS PROGRAMMĒŠANAS\\[0.3cm] VALODAI IMMUTANT}}\\[0.5cm]

    \normalsize{KVALIFIKĀCIJAS DARBS DATORZINĀTNĒS}\\[5cm]
    
    \begin{flushleft}
        Autors: Rolands Frīdemanis\\
        Studenta apliecības Nr.: rf23009\\
        Darba vadītājs: asociētais profesors Dr. sc. comp. Aleksandrs Belovs
    \end{flushleft}
    
    \vfill
    RĪGA, 2025
\end{titlepage}

\selectlanguage{latvian} 
\begin{abstract}
    Mūsdienās liela daļa no vispārīga pielietojuma programmēšanas valodām, satur sematiku, kas paredz, ka datu mainība ir ierasta lieta, tomēr šim pastāv būtisks trūkums, kas ir datu neparedzamība.
    Lai spriešanu par programmas stāvokli padarītu paredzamu, šī darba ietvaros tiek izstrādāta programmēšanas valoda, kuras gramatika un sintakse ierosina noteikta datu nemainību.
    Šis darbs satur valodas specifikāciju un interpretatora arhitektūras dokumentāciju lekserim, parsētājam un abstraktā sintakses koka pārstaigāšanas algoritmam.
    Rezultātā, izmantojot valodu C, tiek izveidota augsta līmeņa, intepretējama, dinamiski tipizēta valoda ar atomāriem datu tipiem.

    \begin{flushleft}
    \textbf{Atslēgvārdi:} interpretators, AST, funkcionālā programmēšana, C valoda, datu nemainība
    \end{flushleft}
\end{abstract} 

\selectlanguage{english} 
\begin{abstract}
    Most modern general-purpose programming languages use grammar and syntax that suggests mutable data being an ordinary matter, which in reality complicates reasoning about program state.
    To make such reasoning predictable, this work explores the design and delelopment of a programming language with explicit syntax and semantics of immutable data. 
    This work contains specification for such language and documentation of the architecture for the lexer, parser and AST-walker of the underlying interpreter.
    As a result, a high-level, interpreted, dynamically typed programming language with only atomic data types is created. The language is implemented in C.

    \begin{flushleft}
    \textbf{Keywords:} interpreter, AST, functional programming, C language, data immutability
    \end{flushleft}
\end{abstract} 

\selectlanguage{latvian} 
\tableofcontents

\newpage
\chapter*{Apzīmējumu saraksts un terminu skaidrojumi}
\addcontentsline{toc}{section}{Apzīmējumu saraksts un terminu skaidrojumi}

\begin{itemize}
  \item \textbf{AST} - Abstraktās sintakses koks - koka datu struktūra.
  \item \textbf{mutabilitāte} - Datu īpašība, kas ļauj mainīt to vērtību pēc sākotnējās inicializācijas. Programmēšanas valodas kontekstā tā izpaužas kā interpretatora uzvedība caur valodas semantiku, kas ļauj mainīt datu vērtības izpildes laikā \cite{immutability}.
  \item \textbf{mutabls} - mutabilitātes īpašība, kas ļauj mainīt datu vērtību pēc sākotnējās inicializācijas. 
  \item \textbf{nemutabls} - mutabilitātes īpašība, kas ļauj mainīt datu vērtību pēc sākotnējās inicializācijas.
\item \textbf{Immutant} - Jauna pašizveidota interpretējama programmēšanas valoda ar datu nemainības semantiku, kas apskatīta šajā darbā.
\end{itemize}

\newpage
\chapter*{Ievads}
\addcontentsline{toc}{section}{Ievads}

Datu mainība un to nepārtraukta plūsma no viena mainīga uz otru ir neapstrīdama daļa no lielas daļas programmatūras. Droši var apgalvot, ka datorsistēmu arhitektūru atmiņas koncepcija ļauj izmantot atmiņu vairākkārtēji. Atmiņu var relocēt, izdzēst, pieprasīt lielākus atmiņas gabalus u.t.t. No šī izriet datu mainības būtība, un līdz šai dienai tā ir iekalta lielā daļā, ja ne visu, programmēšanas un skriptēšanas valodu.   

No otras puses, mainīgiem datiem pastāv īpašība būt neparedzamiem. Kamēr mazas sistēmas spēj tikt galā ar nelielu daudzumu mainīgo, tad lielajās sistēma tas var kļūt par acīmredzamu problēmu. Atmiņa datoram ir viena, tomēr atsaukties uz to var no dažādām vietām dažādos laika brīžos, kas padara spriešanu par datu stāvokli daudz sarežģītāk.  

Programmētāji izmanto iespēju mainīt datus brīvā veidā, jo  programmēšanas valodas un to abstrakcijas ir padarījušas to tik vienkāršu. Lai gūtu vairāk kontroles pār ipriekš minēto uzvedību, valodas no C saimes, Java, JavaScript un citas valodas satur gramatikas, kas ierobežo mainīgu datu inicializāciju un to turpmāko vērtību maiņu. Kā piemēru var minēt \texttt{const} atslēgvārdu no valodas C, kas fiksē doto mainīgo un liedz pārrakstīt tā vērtību, tomēr tas tikai daļēji attiecas uz atsauces tipa vērtībām. Kaut arī šāda tipa mainīgais vienmēr atsauksies tikai uz vienu konkrētu atmiņas apgabalu, nav noteikts, ka vērtība, kas tajā atrodas, nemainīsies. Līdz ar to, \texttt{const} atslēgvārds negarantē patiesu datu nemainību, bet tikai noslēdz to uz \texttt{readonly} pieeju.
Neskatoties uz dažādiem programmēšanas valodu centieniem ierobežot datu mainību, tādas problēmas kā neparedzamas mainīgo vērtības pavedienu izpildes laikā, mainīgo aizstājējvārdu nepārdomāta ieviešana un izmantošana, mainīgo nejauša re-inicializācija u.c. joprojām sastāda lielu daļu programmu.\cite{immutability}

Šis darbs izskata jaunas interpretējamas programmēšanas valodas izveidi, kurai pielietota datu nemainības semantika, cenšoties mazināt programmatūras izstrādes problēmas saistītas ar stāvoklu maiņu. Tas arī nozīmē, ka galvenā ideja kalpo far faktoru valodas nosaukuma izvēlei. Savukārt interpretatora sākotnējā versijā, kas šeit ir izskatīta, ietilpst apstrādes loģika sekojošām daļām: primitīvi datu tipi un to glabāšana mainīgos, ar to saistītā datu nemainības semantika, izteiksmes, tīras un netīras funkcijas, kontroles plūsma un cikli.

\subsubsection{Valodas nolūks}
Valodas Immutant galvenais mērķis ir nodrošināt vienkāršu, viegli apgūstamu programmēšanas valodu, ar datu nemainības semantiku, kas ļauj izstrādāt programmatūru ar minimālu blakņu efektu risku, ko rada datu mainība. Valoda ir paredzēta gan iesācējiem programmētājiem, gan pieredzējušiem izstrādātājiem, kas vēlas izmantot datu nemainības priekšrocības savos projektos. 


% TODO: check if the promoted features are included in the final version and if there is somethign missing or something over-pomised.

\subsubsection{Pārskats}

Šī darba pirmajā nodaļā tiks izskatīta programmēšanas valodas specifikācija, kurai pakārtosies interpretators. Savukārt otrā nodaļa būs veltīta interpretatora arhitektūras pārskatam un tā tehniskai specifikācijai, kā arī tehnoloģijām izmantotām porgrammatūras izstrādei. Trešā un ceturtā nodaļa virzīs uzmanību uz leksera un parsētāja izstrādes detaļām, bet piektā nodaļa būs par rezultējošā AST apstrādi. Tālākajā sestajā nodaļā būs apokopoti rezultāti par jauniegūto valodu un tās interpretatoru, un praktiski demonstrēts valodas pielietojums. Visbeidzot, septītajā nodaļā tiek izvirzītas idejas turpmākai valodas attīstībai, un izskatīts kopsavilkums par paveikto darbu.


\newpage
\chapter{Vispārējs apraksts}

\section{Esošā stāvokļa apraksts}
Uz doto brīdi eksistē vairākas programmēšanas valodas, kas piedāvā dažādus līmeņus datu nemainības atbalstam. Piemēram, funkcionālās programmēšanas valodas kā Haskell un Clojure ir veidotas ap datu nemainības principiem, nodrošinot spēcīgu atbalstu nemutabliem datiem un tīrām funkcijām \cite{haskell, clojure}. No otras puses, imperatīvās valodas kā Python un JavaScript piedāvā iespējas strādāt ar nemutabliem datiem, bet tās nav tik stingras kā funkcionālajās valodās \cite{python, javascript}.

\section{Pasūtītājs}
Sistēma tiek izstrādāta pēc autora iniciatīvas, kvalifikācijas darba ietvaros. 

\section{Produkta perspektīva}
Jaunā programmēšanas valoda Immutant ir paredzēta kā patstāvīgs produkts, kas var tikt izmantots kā rīks dažādiem programmēšanas projektiem. Tā nav atkarīga no jebkuras konkrētas platformas vai sistēmas.

\section{Produkta funkcijas}
Valoda Immutant piedāvā šādas galvenās funkcijas:

\begin{itemize}
  \item \textbf{Datu nemainība:} Valoda Immutant ievieš stingru datu nemainības semantiku, kas nozīmē, ka pēc datu inicializācijas to vērtības nevar mainīt. Tas palīdz samazināt blakusefektu risku un padara programmas uzvedību paredzamu.
  \item \textbf{Vienkārša sintakse:} Valodas sintakse ir veidota tā, lai tā būtu viegli saprotama un lietojama, padarot to pievilcīgu gan iesācējiem, gan pieredzējušiem programmētājiem.
  \item \textbf{Dinamiskā tipizācija:} Valoda Immutant izmanto dinamisko tipizāciju, kas ļauj programmētājiem strādāt ar dažādiem datu tipiem bez nepieciešamības deklarēt to tipus pirms lietošanas.
  \item \textbf{Funkcionālā programmēšana:} Valoda atbalsta daļu no funkcionālās programmēšanas paradigmām, nodrošinot izpildlaikā verificējamas tīras funkcijas, kas palīdz samazināt blakusefektu risku.
  \item \textbf{lvalue: } Angļu valodā "left value" jeb saīsināti lvalue - izteiksme, kas apzīmē atmiņas vietu, kurā var glabāt vērtību.
\end{itemize}

\section{Darījumprasības}

Programmatūrai ir izveidotas šādas darījumprasības:

\begin{itemize}
  \item Valodas sintakse un semantika jābūt viegli saprotamai un lietojamai, lai veicinātu plašu pieņemšanu starp programmētājiem.
  \item Intepretatoram ir jāatbalsta gan interarktīvās vides režīmu, gan skriptu izpildi no datnēm.
\end{itemize}

\section{Sistēmas lietotāji}
Sistēmas galvenie lietotāji ir programmētāji, kas vēlas izmantot datu nemainības priekšrocības savos projektos. Tie var būt gan iesācēji, kas mācās programmēšanu, gan pieredzējuši izstrādātāji, kas meklē jaunu rīku saviem projektiem. Spēkā ir pieņēmums, ka lietotājam ir pamata izpratne par programmēšanas konceptiem un terminoloģiju un tas ir iepazinies ar programmēšanas valodu Immutant dokumentāciju.

\begin{figure}[h]   
    \centering
    \includegraphics[scale=0.6]{assets/dataflow/dfd_lvl_0.jpg}  
    \vspace{0.5cm}  
    \caption{0. līmeņa datu plūsmas diagramma}           % optional
    \label{fig:dfd_lvl_0}                  
\end{figure}

\section{Vispārējie ierobežojumi}
Interpretators ticis izstrādāts Mac OS platformai, tāpēc tiek pieņemts, ka lietotājam darbojas šajā operētājsistēmā. Tomēr interpretatora kods ir rakstīts tā, lai to būtu viegli pārnest uz citām platformas ar minimālām izmaiņām. 


\section{Pieņēmumi un atkarības}

\begin{itemize}
  \item Pirmkoda datnes, kas tiek padotas izpildei interpretatoram nav aizsargātas pret lasīšanu. 
  \item Pirmkods ir rakstīts atbilstoši valodas Immutant gramatikai un sintaksei.
\end{itemize}

\newpage


\chapter{Valodas specifikācija}

% Šīs nodaļas nolūks ir formalizēt prasības, kas noteiktas uz valodu, kas attiecīgam interpretatoram ir jāspēj īstenot. Šī nodaļa neizklāsta implementācijas detaļas, bet gan drīzāk kalpo kā lietotāja rokasgramāta valodas lietošanā.
% Nodaļā izklāstītā informācija netikai palīdz lasītājiem iepazīties ar tās uzbūvi valodas lietošanas un attīstības nolūkos, bet arī nosaka prasības, kas tiek attiecīgi nostādītas uz Immuntant programmēšanas valodas interpretatoru.
% Nodaļā ir skaidroti valodā definētie datu tipi, mainīgie funkcijas, un programmas vadības mehānismi, datu nemainības semantika, kas attiecas uz noteikta veida vērtībām, kā arī tiek uzskaitīti kļūdu paziņojumi un to attiecīgie skaidrojumi.
% Turpretim, lai iepazītos ar tehniskām implementācijas detaļām, skatīt nākamo nodaļu ~\ref{chap:arch}.


\section{Datu tipi}

Programmēšanas valodas pamatu veidu datu tipi un ar to saistītie mehānismi. Valodā Immutant tiek definēti tikai primitīvie datu tipi, kas satur skaitļus, virknes un patiesuma vērtības. Datu tipizācija ir dinamiska, kas nozīmē, ka datu tipa pārbaude tiek veikta izpildes laikā.

\subsection{Primitīvie datu tipi}

Pirmatnējā Immutant valodas versijas tipu sistēma ietver tikai primitīvos datu tipus, t.i., pamata datu tipi, kas vēlāk var veidod citus tipus, piemēram, masīvus, objektus u.c.  Salikti datu tipi netiek iekļauti valodas versijā, kas tiek aprakstīta šajā dokumentā, lai saglabātu interpretatora vienkāršību un vairāk koncentrētos uz datu nemainības semantikas īstenošanu.

\subsubsection{Virknes}
Virkne ir jebkurš simbolu kopums, kas ir ietverts starp dubultpēdiņām.
Tās var saturēt jebkādus simbolus, tostarp specsimbolus, kā \texttt{@,\^\space,\&} u.c. Proti, vikrnēs nav liegts izmantot speciālos atslēgas vārdus, ko pati valoda ir definējusi, piemēram, \texttt{mutant} (vairāk par to minēts sadaļā ~\ref{section:vars}).
Piemērs dažādām viknēm seko zemāk. Tāpat, arī tikai vienu rakstzīmi ir atļauts uzdot ar virknes tipu.

\begin{verbatim}
"", "someString", "garumzīmes īāē", " ", ,"\""
\end{verbatim}

Izņēmuma gadījums, ir dubultpēdiņu simbola izmantošana iekš vikrnes. Lai neuztvertu to kā virknes beigas, tas ir jāekranē ar vadošo simbolu \texttt{\textbackslash}. Realitātē neekranizētas virknes, kas satur specsimbolus ir pamata sintakses kļūda, ko programmētāji bieži vien pieļauj neuzmanības dēļ. 

Piemērs tādai virknei:

\begin{verbatim}
"They call themselves \"the wolves\""
\end{verbatim}

Rezultātā atkārtots dubultpēdiņu simbols netiek uztvers kā virknes beigu indenkators, bet gan kā daļa no virknes vērtības, un tiek panākts sekojošs teksts:

\begin{verbatim}
They call themselves "the wolves"
\end{verbatim}

Uz ekranizēšanu attiecas arī pats ekranizēšanas simbols \texttt{\textbackslash}. Ja ir nepieciešamība to iekļaut virknē, tas arī ir jāekranizē sekojošā veidā:

\begin{verbatim}
"There is something mysterious about the \"\\\" character."
\end{verbatim}

Dotās virknes rezultējošais teksts ir: 

\begin{verbatim}
There is something mysterious about the "\" character.
\end{verbatim}

\subsubsection{Skaitļi}

Skaitlis ir jebkura vērtība no Reālo skaitļu kopas. Ir svarīgi uzsvērt, ka irracionāli skaitļi tiek implementēti pēc IEEE 754 standarta, tāpēc realitātē tie nav līdz galam irracionāli, bet gan ir to aproksimētas vērtības. Daļskaitļu decimālo daļu atdala ar punkta (\char`.) rakstzīmi.

Piemērs skaitliskām vērtībām seko zemāk:

\begin{verbatim}
102, -9, -0.3, 421.5632, PI
\end{verbatim}

Dotajā piemērā \texttt{PI} ir viena no valodā eksistējošām konstatēm, kas satur aproksimētu matemātiskās konstantes $\pi$ vērtību (\texttt{\char`~3.1415926535}).

Valodas gramatika atļauj izmantot vadošo punktu priekšā skaitlim, kas apzīmē decimāldaļu skailim nulle. Piemēram, decimālskaitlis \texttt{.34} ir identisks ar \texttt{0.34}.


\subsubsection{Patiesuma vērtības}

Patiesuma vērtības valodā Immutant seko divvērtīgai loģikai, kur ir tikai divas iespējamās vērtības: patiesa un aplama. Patiesu vērtību apzīmē ar \texttt{true}, bet aplamu ar \texttt{false}. Patiesuma vērtības ir pamats loģiskām izteiksmēm, kas tiek izmantotas kontroles plūsmas konstrukcijās, piemēram, nosacījumos un ciklos. 

Patiesuma vērtību var iegūt vai nu to tieši uzdodot, vai arī piemērojot loģiskos operatorus (skat. sadaļu ~\ref{section:operators}).

\section{Mainīgie}
\label{section:vars}

Mainīgie ir programmēšanas valodas konstrukcija, kas ļauj saglabāt datus atmiņā un atsaukties uz tiem vēlāk programmā. Immutant valodā nošķir 2 veidu manīgos: tie kas nepaļaujas datu mutācijai jeb mainībai un tie, kas tai paļaujas. 

\subsection{Mainīgo deklarācija un inicializācija}

Mainīgo deklarācija ir apgalvojums, kas reģistrē mainīgā identifikatoru atmiņā, bet inicializācija ir apgalvojums, kas piešķir mainīgajam sākotnējo vērtību.

Mainīgo deklarācija un inicializācija var notikt vienā solī, vai arī tās var izpildīt atsevišķi, tomēr jātur prātā ka mainīgajam ir jābūt deklarētam pirms tā inicializācijas vai jebkādas citas izmantošanas programmā, pretējā gadījumā tiek izmests izņēmums \texttt{UndeclaredVariableException}.

Mainīgos deklarē sekojošā formā:
\begin{verbatim}
<mutability> <identifier>;
\end{verbatim}


Mainīgā deklarācija sākas ar vienu no 2 atslēgvārdiem <mutability> - \texttt{mutant} un \texttt{immutant} -, kas nosaka mainīgā mutācijas īpašību. 

Mainīgo deklarāciju nobeidz patvaļīgs identifikators <identifier> jeb mainīgā nosaukums. Identifikators var saturēt burtus, ciparus un pasvītrojuma simbolu (\texttt{\_}), bet nedrīkst sākties ar ciparu. Tāpat, identifikators nedrīkst sakrist ar kādu no valodas atslēgvārdiem, piemēram, \texttt{mutant}, \texttt{immutant}, \texttt{if}, \texttt{else} u.c. (pilnu atslēgvārdu sarakstu skatīt sadaļā ~\ref{section:keywords}).

Mainīgā inicializācijai ir jāseko vienai no sekojošām formām:

\begin{verbatim}
<identifier> = <expression>;
\end{verbatim}  

\begin{verbatim}
<mutability> <identifier> = <expression>;
\end{verbatim}  

Pirmo gadījumu lieto, ja mainīgā deklarācija ir veikta iepriekš, bet otro, ja mainīgā deklarācija un inicializācija notiek vienlaicīgi.

Lai inicializētu mainīgo, t.i. piešķirtu tam vērtību, ir jāizmanto piešķiršanas operatora simbols (\texttt{=}), kam seko izteiksme <expression>, kas rezultātā atgriež vērtību, ko piešķir mainīgajam.

\subsection{Mainīgo mutabilitāte}
\label{section:var-mutability}

Mainīgo mutabilitāte jeb mainības īpašība nosaka, vai mainīgā vērtību ir iespējams mainīt pēc tā inicializācijas. 
Valodā immutant ir divu veidu mainīgie: \textbf{mutable} un \textbf{immutable}, tos deklarē izmantojot atslēgvārdus \texttt{mutant} un \texttt{immutant} attiecīgi. Turpmāk šajā darbā tiks izmantoti šo terminu latviešu atvasinājumi, t.i., \textbf{mutabilitāte, mutabls} un \textbf{nemutabilitāte, nemutabls} lai raksturotu datu mainības īpašības.

\subsubsection{Mutabilitāte \texttt{mutable}}

Mutabls, atvasināts no angļu valodas vārda \texttt{mutable}, ir tāds mainīgais, kura vērtību ir iespējams mainīt pēc tā inicializācijas. Tādus mainīgos deklarē ar atslēgvārdu \texttt{mutant}.

Jebkurš mainīgais, kas deklarēts ar \texttt{mutable}, var tikt piešķirts jaunu vērtība jebkurā programmas izpildes brīdī pēc tā inicializācijas. Tas ļauj programmētājiem veidot dinamiskākas programmas, kurās dati var mainīties atkarībā no programmas loģikas un lietotāja ievades. Proti, to ir ieteicams darīt tikai gaījumos, kad risinājumi ar nemutabliem mainīgajiem ir pārāk sarežģīti vai neefektīvi.

\subsubsection{Mutabilitāte \texttt{immutable}}

Nemutabls, atvasināts no angļu valodas vārda \texttt{immutable}, ir tāds mainīgais, kura vērtību nav iespējams mainīt pēc tā inicializācijas. Tādus mainīgos deklarē ar atslēgvārdu \texttt{immutant}. Šeit ir pamanāma acīmredzama vārdu spēle, jo \texttt{immutant} ir neoloģisms angļu valodā, kas apvieno vārdus \texttt{immutable} un \texttt{mutant} radot jaunu vārdu, kas apzīmē mainīgo, kas nav maināms. Tas atbilst nemutabilitātes semantikai, kas izmantota funkcionālajā programmēšanā, un tādēļ arī sekojošs nosaukums izvēlēts šai programmēšanas valodā.

Nemutablus mainīgos nedrīkskt re-inicializēt, tas nozīmē, ka sekojoša programma izmetīs kļūdu \texttt{ImmutableVariableModificationException}:
\begin{verbatim}
immutant x = 10;
x = 20; // Izmests izņēmums: ImmutableVariableModificationException
\end{verbatim}

Nemutabli mainīgie nedrīkt arī tik padoti kā argumenti netīrām funkcijām (skat. sadaļu ~\ref{section:functions}), jo tas pārkāpj datu nemainības principu. Pretējā gadījumā netīras funckijas varētu mainīt nemutabla mainīgā vērtību, kas noved pie neparedzamas programmas uzvedības. Šo uzvedību demonstrē šāds piemērs:

\begin{verbatim}
immutant num = 5;

impure fn modify(value) {
    value += 10; // Mēģinājums mainīt nemutabla mainīgā vērtību
}

modify(num); // Izmests izņēmums: ImmutableVariableModificationException
\end{verbatim}

Turpretim, tīras funkcijas (skat. nodaļu ~\ref{section:functions}) var pieņemt gan mutablus, gan nemutablus mainīgos kā argumentus, jo tīras funkcijas pēc definicījas neietekmē ārējo stāvokli un nemaina dotās vērtības (nenotiek blakus efekti).

Tā kā valodā Immutant netiek definēti sarežģītāki datu tipi, piemēram, masīvi vai objekti, tad nav nepieciešams apskatīt mutabilitātes īpašības attiecībā uz šādiem datu tipiem. 

\subsection{Datu tipa konversija}
\label{section:datatype-conversion}

Pastāv gadījumi, kad parādās nepieciešamība konvertēt viena datu tipa vērtību uz cita datu tipa vērtību. Piemēram, ja kādu aritmētisku operatoru, piemēram, saskaitīšanu, pielieto virknei un skaitlim. Tad ir nepieciešams konvertēt vienu no operandiem uz otra datu tipu, lai veiktu šo operāciju, šajā gadījumā virkne jāparveido uz skaitli vai skaitlis par virni. 

Daudzās valodās eksistē netiešā datu tipu konversija jeb tā, ko interpretators pats veic pēc vajadzības. Piemēram, valodā Javascript izteiksme \texttt{"5" + 3} rezultātā atgriež virkni \texttt{"53"}, jo interpretators veic netiešo tipu konversiju, pārvēršot skaitli \texttt{3} par virkni \texttt{"3"} un pēc tam veicot virkņu konkatenāciju \cite{ecma-262}. Šī ir gan priekšrocība, jo operators tiek netieši pārslogots uz darbību ar virknēm, nevis skaitļiem, tomēr tas var novest pie neparedzamas uzvedības, kas zināmā sabiedzrībā rada jokus, par to kā Javascript "5" + 3 ir "53", nevis 8.

Tā kā programmēšanas valodas Immutant galvenais mērķis ir palīdzēt programmētājiem rakstīt paredzamāku kodu, datu tipu konversija tiek atbalstīta tikai tiešā veidā. Tas nozīmē, ka saskaitot virkni un skaitli, nav jāpiedomā vai rezultātā radīsies virkne vai skaitlis, jo zināms, ka neviennozīmīgu operāciju izpilde izmetīs izpildlaika kļūdu \texttt{ImplicitionConversionException}.

No otras puses, ja programmas autors tiešām vēlas pārveidot vienu datu tipu uz citu, tad valoda Immutant piedāvā iebūvētas funkcijas, kas veic šo darbību. Šīs funkcijas ir aprakstītas zemāk:

\begin{itemize}
  \item \texttt{toString(value)} - Atgriež `value` vērtību pārvēstu virknes datu tipā.
  Pārvēršanas loģika - doto vērtību pārvērš par virkni, izmantojot tās bāzes reprezentāciju. Piemēram, skaitlis \texttt{42} tiek pārvērsts par virkni \texttt{"42"}, bet patiesuma vērtība tiek pārvērsta par virkni \texttt{"true"} vai \texttt{"false"} attiecīgi. 
  \item \texttt{toNumber(value)} - Atgriež vērtības skaitlisko reprezentāciju. Ja virkne satur derīgu skaitlisko vērtību, tad tā tiek pārvērsta par atbilstošu skaitli. Piemēram, virkne \texttt{"123.45"} tiek pārvērsta par skaitli \texttt{123.45}. Ja virkne nesatur derīgu skaitlisko vērtību, tiek izmests izņēmums \texttt{InvalidTypeConversionException}. patiesa vērtība \texttt{true} tiek pārvērsta par skaitli \texttt{1}, bet \texttt{false} par skaitli \texttt{0}. 
  
  Virkne ir uzskatāma par derīgu skaitlisko vērtību, ja tā satur tikai skaitli vai decimālskaitli. Ja skailim apkārt ir tukšuma simboli, tie tiek ignorēti. Piemēram, virknes \texttt{"  42  "} un \texttt{"-3.14"} ir derīgas skaitliskās vērtības, bet virknes \texttt{"123abc"} un \texttt{"hello"} nav derīgas.
  \item \texttt{toBoolean(value)} - Pārveido dotā operanda vērtību par patiesuma vērtību. Vērtības \texttt{0}, \texttt{"0"}, \texttt{\char`"\char`"} (tukša virkne) un \texttt{false} tiek pārvērstas par aplamu vērtību \texttt{false}. Visas pārējās vērtības tiek pārvērstas par patiesu vērtību \texttt{true}.
  \item \texttt{typeOf(value)} - Atgriež dotā operanda datu tipu kā virkni. Pieņem jebkura datu tipa vērtību kā argumentu, un atgriež vienu no šādām virkņu vērtībām: \texttt{\char`"number"}, \texttt{\char`"string"}, \texttt{"boolean"}.
\end{itemize}

Pie tam, datu tipu konversijas funkcijas neietekmē dotā operanda sākotnējo vērtību un datu tipu, bet gan atgriež jaunu vērtību ar konvertēto tipu. Ja datu tipa konversija nav iespējama, tiek izmests izņēmums \texttt{InvalidTypeConversionException}.

\subsection{Mainīgo redzamība}
Mainīgo redzamība ir tāda īpašība, kas nosaka kurās programmas daļas ir pieejams konkrētais mainīgais. Valodā Immutant mainīgo redzamība tiek noteikta pēc to deklarācijas vietas. Mainīgā redzesloks ir tā programmas daļa, kurā ir pieejams attiecīgais mainīgais.

Piemērs globāla mainīgā deklarācijai un tā izmantošanai funkcijā:

\begin{verbatim}
immutant globalVar = 10;

fn printGlobalVar() {
  print(globalVar);
}

printGlobalVar(); // Izvada: 10
\end{verbatim}

Mainīgie, kas deklarēti ārpus jebkuras funkcijas ķermeņa, ir pieejami visā programmas kodā, ieskaitot visas funkcijas. Šādi mainīgie tiek saukti par globāliem mainīgajiem, t.i. to redzesloks aptver visu programmu.

Funkcijas un jebkādas citas konstrukcijas ar ķermeni (valodā Immutant tie arī ir cikli un nosacījumi) izveido savu redzesloku, un attiecīgi mainīgie deklarēti šajā redzeslokā ir pieejami tikai šajā konstrukcijā un tās iekšējos redzeslokos.

Piemērs lokāla mainīgā deklarācijai un tā izmantošanai funkcijā:
\begin{verbatim}
fn doMagic() {
  immutant localVar = 5;
  if(true) {
    mutant anotherLocalVar = localVar + 10;
  }
}
doMagic();
\end{verbatim}

Kā var redzēt, localVar eksistē visā \texttt{doMagic} funckijas redzeslokā, tai skaitā arī nosacījuma \texttt{if} ķermenī. Šajā konkrētajā gadījumā \texttt{anotherLocalVar} ir pieejams tikai \texttt{if} ķermenī.

Mainīgie, kurus mēģina izmantot ārpus to deklarācijas redzesloka, izraisa izņēmumu \texttt{UndeclaredVariableException}. Pēc savas būtības tā ir nedeklarēto mainīgo izmantošana. Skatīt piemēru zemāk.

\begin{verbatim}
fn setLocalVar() {
  immutant localVar = 5;
}
setLocalVar();
print(localVar); // Izmests izņēmums: UndeclaredVariableException
\end{verbatim}

Līdzīgi situācija rodas, izmantojot mainīgo pirms tā deklarācijas:
\begin{verbatim}
print(globalVar); // Izmests izņēmums: UndeclaredVariableException
immutant globalVar = 10;
\end{verbatim}

\section{Operatori un inzteiksmes}
\label{section:operators}

\subsubsection{Izteiksmes}

Izteiksmes ir konstrukcija, kas atgriež kādu vērtību. Piemēram, funckijas izsaukums ir izteiksme, kas rezultātā atgriež izpildītas funkcijas vērtību. Pie tam, arī aritmētiska vai loģiska operācija ir izteiksmes konstrukcijas, jo atgriež skaitlisku vai patiesuma vērtību attiecīgi.

\subsection{Apgalvojumi}

Apgalvojumi jeb deklarācijas ir izteiksmes, kas veic kādu darbību, bet pašas par sevi nedod nekādu vērtību. Piemēram, mainīgo inicializācija ir apgalvojums, jo tā veic darbību - piešķir vērtību mainīgajam, bet pati par sevi nedod nekādu vērtību.

Funkcijas definīcija ir apgalvojums, jo tā arī veic darbību - reģistrē funkciju atmiņā, bet pati par sevi nedod nekādu vērtību.

\subsubsection{Operatori}

Operatorus iedala unāros un bināros. Unārs operators tiek pielietots tikai vienam operandam, kur tai pat laikā bināri operatori ir pielietoti 2 operandiem. Piemmēram, negācijas operators, kas apvērš patiesuma vērtību ir pielietots vienam operatoram, bet saskaitīšanas operators ir pielietots diviem skaitļiem, producējot to summu.

Vērts precizēt, ka gadījumā, ja operators ir binārs, tad tas tiek rakstīts abiem operandiem starpā. Turpmāk tekstā kreisas operands tiek definēts kā šāda bināra operatora operands, kas atrodas pa kreisi no operatora, un labais kas attiecīgi ir pa labi no tā. Piemēram, izteiksmē \texttt{23 + 45} skaitlis \texttt{23} ir kreisas operands, \texttt{45} ir labais operands, un \texttt{+} ir binārais summas operators. \\

\paragraph{Aritmētiskie operatori:} tiek pielietoti skaitļiem, un atgriež skaitlisku vērtību.

\begin{itemize}
  \item \texttt{+} saskaitīšana, atgriež divu skaitļu summu
  \item \texttt{-} atņemšana, atgriež pirmā skaitļa vērtību mīnus otrā skaitļa vērtību
  \item \texttt{*} reizināšana, atgriež divu skaitļu reizinājumu
  \item \texttt{/} dalīšana, atgriež kreisā operanda dalījumu ar labo operandu. Ja labais operands ir nulle, tad tiek izmests izņēmums \texttt{InvalidOperationException}
  \item \texttt{\%} modulis, atgriež kreisā skaitļa operanda moduli ar labā operanda vērtību
\end{itemize}

\textbf{Aritmētiskās salīdzināšanas operatori:} tiek pielietoti skaitļiem, un atgriež patiesuma vērtību. 
\begin{itemize}
  \item \texttt{>} lielāks par, atgriež patiesu vērtību, ja kreisā operanda vērtība ir lielāka par labā operanda vērtību
  \item \texttt{<} mazāks par, atgriež patiesu vērtību, ja kreisā operanda vērtība ir mazāka par labā operanda vērtību
  \item \texttt{>=} lielāks vai vienāds ar, atgriež patiesu vērtību, ja kreisā operanda vērtība ir lielāka vai vienāda ar labā operanda vērtību
  \item \texttt{<=} mazāks vai vienāds ar, atgriež patiesu vērtību, ja kreisā operanda vērtība ir mazāka vai vienāda ar labā operanda vērtību
\end{itemize}

\textbf{Ekvivalences operatori:} tiek pielietoti jebkura datu tipa operandiem un atgriež patiesuma vērtību. 
\begin{itemize}
  \item \texttt{==} ir vienāds, atgriež patiesu vērtību, ja abu operandu vērtības ir vienādas. Proti, atgriež aplamnu vērtību, ja abi operandi ir ar dažādiem datu tipiem.
  \item \texttt{!=} nav vienāds ar, atgriež patiesu vērtību, ja abu operandu vērtības nav vienādas, tai skaitā arī ja to datu tipi ir dažādi.
\end{itemize}

\textbf{Loģiskie operatori:} Pielietoti patiesuma vērtībām, un atgriež patiesuma vērtību.
\begin{itemize}
  \item \texttt{!} nēgācija, apvērš patiesuma vērtību. Ir unārs operators. 
  \item \texttt{\&\&} konjukcija, atgriež patiesu vērtību, ja abu operandu vērtības ir patiesas
  \item \texttt{||} disjunkcija, atgriež patiesu vērtību, ja vismaz viena no abu operandu vērtībām ir patiesa.
\end{itemize}

\subsection{Operatoru darbības kārtība}

Katram operatoram ir noteikta sava prioritāte, tas ir, kārtība, kādā apakšizteiksmes ar vairākiem operatoriem tiek izpildītas. Piemēram, reizināšanas operatoram ir augstāka prioritāte, nekā saskaitīšanas operatoram, tāpēc izteiksme \texttt{2 + 3 * 4} tiek izskaitļota kā \texttt{2 + (3 * 4)}, nevis \texttt{(2 + 3) * 4}. 
Zemāk ir uzskaitīti operatori to prioritātes secībā, no augstākās uz zemāko. Operatori ar vienādu prioritāti tiek minēti kopīgi vienā saraksta apakšpunktā.

\begin{itemize}
  \item \texttt{!} (unārs nēgācijas operators)
  \item \texttt{*}, \texttt{/}, \texttt{\%} (aritmētiskie reizināšanas, dalīšanas un modula operatori)
  \item \texttt{+}, \texttt{-} (aritmētiskie saskaitīšanas un atņemšanas operatori)
  \item \texttt{>}, \texttt{<}, \texttt{>=}, \texttt{<=} (aritmētiskie salīdzināšanas operatori)
  \item \texttt{==}, \texttt{!=} (ekvivalences operatori)
  \item \texttt{\&\&} (konjukcija)
  \item \texttt{||} (disjunkcija) 
\end{itemize}

Ir kritiski atzīmēt, ka dažādu operatoru izpildes kārtību var mākslīgi paaugstināt, izmantojot apaļās iekavas. Izteiksmes iekavās tiek izpildītas pirmās, neatkarīgi no tajās esošo operatoru prioritātes.

Skaidrības labad, tiek dots piemērs ar saliktu izteiksmi un tās izvērtēšanas kārtību:
\begin{verbatim}
3 + 4 % 2 == 3 && true || false
\end{verbatim}

Alternatīvi, to var pārrakstīt ar iekavām, kas ilustrē izvērtēšanas kārtību:
\begin{verbatim}
((3 + (4 % 2)) == 3) && (true || false)
\end{verbatim}

Tātad, apakšizteiksme 
\begin{verbatim}
  ((3 + (4 % 2)) == 3)
\end{verbatim}
tiek izvērtēta pirmā (jo atrodas labajā pusē), kas rezultātā atgriež patiesu vērtību.
Pēc tam tiek izvērtēta apakšizteiksme
\begin{verbatim}  (true || false)
\end{verbatim}
kas arī atgriež patiesu vērtību. Beigās tiek pielietots disjunkcijas operators \texttt{||}, kas atgriež patiesu vērtību, jo vismaz viens no abiem operandiem (kas īstenībā ir izteiksmes) ir patiess.

\section{Izvērtēšanas kārtība}
Līdzīgi kā daudzās citās programmēšanas valodās, piemēram Java un Ruby, arī valodā Immutant izteiksmju izvērtēšanas kārtība ir no kreisās uz labo pusi. Tas nozīmē, ka izteiksmes kreisais operands tiek izvērtēts pirms labā operanda. Tas, gan, negarantē ka jebkuras izteiksmes pirmie kreisējie operandi tiks izvērtēti pirmie, jo saliktas izteiksmes ar vairāk par vienu operatoru ņem vērā operatoru prioritātes un asociativitāti.

Zemāk ir dots piemērs, kas ilustrē šo izvērtēšanas kārtību:

\begin{verbatim}
pure fn add(a, b) {
    return a + b;
}

immutant sum = add(2, 3) + 4;
\end{verbatim}

Dotajā piemēra mainīgajā (skat. \ref{section:vars}) \texttt{sum} tiek piešķirta vērtība, kas pēc būtības ir  izvērtēts izteiksmes \texttt{add(2, 3) + 4} rezultāts. Tā kā izteiksmes kreisais operands ir funkcijas izsaukums (skat. \ref{section:functions}) \texttt{add(2, 3)}, tad vispirms tiek izvērtēta šī apakšizteiksme, kas rezultātā atgriež skaitli \texttt{5}. Pēc tam tiek izvērtēts labais operands \texttt{4} (tas ir parasts skaitlis, tāpēc šeit netiek padarīts daudz darba), un beigās tiek pielietots saskaitīšanas operators \texttt{+}, kas atgriež summu \texttt{9}. Tātad, mainīgajam \texttt{sum} tiek piešķirta vērtība \texttt{9}.

\subsection{Saīsinātā izvērtēšana}

Interpretatora optimizācijas nolūkos, valoas specifikācijā ietilpst arī saīsinātās izvērtēšanas mehānisms, kas ļauj izvairīties no nevajadzīgu apakšizteiksmju izvērtēšanu, loģiskajās izteiksmēs ar disjunkciju \cite{short-circuit-logic}.

Pēc definīcijas, loģiskā izteiksme ar disjunkciju ir patiesa, ja vismaz viens no tās operandiem ir patiess.
Tā kā valodā Immutant izteiksmes tiek izvērtētas no kreisās puses uz labo, tad ir pietiekami izvērtēt tikai kreiso operandu, ja tas ir patiess.

Piemēram, izteiksme \texttt{true || (someFunction() + 5 > 10)} izvērtējas kā patiesa, pie tam interpretators noignorēs (neizvērtēs) labo operandu.

\section{Funkcijas}
\label{section:functions}

Funkcijas ir pilnībā vai daļēji izoltēts program-kods, kas var tikt izsaukts un izmantots ar dažādiem parametriem, dažādās vietās un dažādos laika brīžos. Funkcijas pašas par sevi ir daļa no programkoda, tomēr, lai tās varētu tikt izpildītas, ir nepieciešams tās izsaukt. 

Funkcijas definē sekojošā formā:
\begin{verbatim}
<purity> fn <identifier>(<parameters>) {
    <statements>
}
\end{verbatim}

<purity> apzīmē funckcijas īpašību mainīt datus ārpus tās lokālā konteksta. Matemātikā "impure" jeb tiešā tulkojumā no angļu valodas "netīrs" apzīmē funkcijas, kas maina ārējos stāvokļus vai ir atkarīgas no tiem. Savukārt "pure" jeb "tīras" funkcijas ir tādas, kas neietekmē ārējos stāvokļus un ir atkarīgas tikai no to parametriem. Tīru funckiju izmantošana programkodā ir ieteicama, jo tā padara programmu prognozējamāku un vieglāk saprotamu, jo zināms ka tīras funckijas var izsaukt tikai citas tīras funkcijas vai izteiksmes, kas nozīmē, ka tās nevienā brīdī neizmaino ārējo stāvokli. Tātad, \texttt{pure} atslēgvārds tiek lietots, lai definētu tīru funkciju, bet \texttt{impure} - netīru. Ja funkcija ir definēta kā tīra, tad tās ķermenī nav atļauts izsaukt netīras funkcijas vai veikt citas darbības, kas maina ārējo stāvokli. No otras puses, šī atslēgvārda lietošana nav obligāta, jo valodā Immutant pēc noklusējuma visas funkcijas tiek uzskatītas par tīrām.

\begin{verbatim}
fn <identifier>(<parameters>) {
    <statements>
}
\end{verbatim}

Augstāk redzamajā piemērā funkcija tiek definēta kā tīra, jo nav lietots neviens no tīrības īpašības atslēgvārdiem. Atslēgvārds \texttt{fn} apzīmē, ka pēc tā seko funkcijas definicija. <identifier> satur funckcijas nosaukumu, kas ir unikāls identifikators atmiņā. Uz funckiajs nosaukumu attiecas tie paši noteikumi, kas minēti sadaļā ~\ref{section:vars} par mainīgo identifikatoriem.

Pēc funkcijas nosaukuma seko apaļās iekavas, kas satur parametru sarakstu <parameters>. Parametri ir iekšējā funckijas konteksta mainīgie, kas tiek nodoti funkcijai tās izsaukšanas brīdī, un kuru vērtības funkcija izmanto savā darbībā. Parametru saraksts ir komatu atdalītu parametru virkne. Ja funkcijai nav parametru, tad iekavas ir tukšas.

Funkcijas ķermenis <statements> ir ietverts figūriekavās, un satur apgalvojumus un izteiksmes, kas tiek izpildītas, kad funkcija tiek izsaukta. Funkcijas ķermenī ir jābūt vismaz vienam apgalvojumam vai izteiksmei. Ja funkcija ir tīra, tad tās ķermenī nav atļauts izsaukt netīras funkcijas vai veikt citas darbības, kas maina ārējo stāvokli.

Piemērs tīrai funkcijai, kas aprēķina divu skaitļu summu:
\begin{verbatim}
pure fn add(a, b) {
    return a + b;
}
\end{verbatim}

Piemērs netīrai funkcijai, kas pieskaita jaunu skaitli globālam mainīgajam:
\begin{verbatim}
mutant num = 4;
impure fn addGlobal(newNum) {
    num += newNum;
}
\end{verbatim}

Funkcijas izsaukums ir izteiksme, kas satur funckijas nosaukumu, kam seko apaļās iekavas ar argumentu sarakstu. Argumenti ir vērtības, kas tiek nodotas funkcijai tās izsaukšanas brīdī, un kuru vērtības funkcija izmanto savā darbībā. Argumentu saraksts ir komatu atdalītu argumentu virkne. Ja funkcijai nav argumentu, tad iekavas ir tukšas. Argumentus padod funckijai secīgi, tādā pašā secībā kā tie ir definēti funkcijas parametru sarakstā. 

Piemērs funkcijas izsaukumiem:
\begin{verbatim}
addGlobal(5);
immutant sum = add(3, 7);
\end{verbatim}

\subsection{Iebūvētas funckijas}

Valodā Immutant ir definētas sekojošas iebūvētas funkcijas:
\begin{itemize}
  \item \texttt{print(value)} - Izvada dotā operanda vērtību uz konsoli. Pieņem jebkura datu tipa vērtību kā argumentu, un izvada tās reprezentāciju kā virkni uz konsoli.
  \item \texttt{input(prompt)} - Parāda dotā virknes tipa argumenta vērtību kā uzvedni lietotājam, un gaida lietotāja ievadi. Atgriež lietotāja ievadīto vērtību kā virknes datu tipu.
  \item \texttt{toString(value), toNumber(value), toBoolean(value), typeOf(value)} - Datu tipu konversijas funkcijas, kas aprakstītas sadaļā ~\ref{section:datatype-conversion}
\end{itemize}

\section{Kontroles plūsma}
Kontroles plūsma ir mehānisms, kas nosaka programmas izpildes secību. Valodā Immutant ir definēti sekojoši kontroles plūsmas mehānismi: \texttt{if-else} zarošanās un cikls \texttt{while}.

\subsection{Apgalvojums if-else}

Apgalvojums \texttt{if-else} ļauj izpildīt dažādas koda daļas atkarībā no nosacījuma izpildes. Sintakse ir sekojoša:
\begin{verbatim}
if (<condition>) {
    <statements>
} else {
    <statements>
}
\end{verbatim}

<condition> ir loģiska izteiksme, kas rezultātā atgriež patiesuma vērtību. Ja izteiksmes vērtība ir patiesa, tad tiek izpildīti apgalvojumi <statements> iekš pirmās figūriekavas. Ja izteiksmes vērtība ir aplama, tad tiek izpildīti apgalvojumi <statements> iekš otrās figūriekavas pēc atslēgvārda \texttt{else}.

Ja ir nepieciešams izpildīt vairākus nosacījumus, tad var izmantot vairākas \texttt{else if} zarošanās. Sintakse ir sekojoša:
\begin{verbatim}
if (<condition1>) {
    <statements1>
} else if (<condition2>) {
    <statements2>
} else {
    <statements3>
}
\end{verbatim}

Pie tam, apgalvojums \texttt{else} nav obligāts, un to var izlaist, ja nav nepieciešams izpildīt kodu gadījumā, ja neviens no nosacījumiem nav izpildīts.

Piemērs programmai, kas atkarība no skaitļa vērtības izvada atbilstošu ziņojumu:
\begin{verbatim}
immutant num = 10;

if (num > 0) {
    print("Number is greather than zero");
} else if (num < 0) {
    print("Number is less than zero");
} else {
    print("Number is zero");
}
\end{verbatim}

\subsection{Cikli}
Cikls \texttt{while} ļauj izpildīt koda daļu atkārtoti, kamēr nosacījums ir izpildīts. Sintakse ir sekojoša:
\begin{verbatim}
while (<condition>) {
    <statements>
}
\end{verbatim}

<condition> ir loģiska izteiksme, kas rezultātā atgriež patiesuma vērtību. Ja izteiksmes vērtība ir patiesa, tad tiek izpildīti apgalvojumi <statements> iekš figūriekavām. Pēc apgalvojumu izpildes, nosacījums tiek pārbaudīts vēlreiz, un ja tas joprojām ir patiess, tad apgalvojumi tiek izpildīti vēlreiz. Šis process turpinās, kamēr nosacījums kļūst aplams. Ja nosacījums sākotnēji ir aplams, tad cikla ķermenis netiek izpildīts ne reizi.

Ciklisku darbību var nodeomstrēt ar fibonacci skaitļu virknes ģenerēšanu:
\begin{verbatim}
immutant n = 10; // Cik fibonacci skaitļus ģenerēt
immutant prev = 0;
immutant curr = 1;
immutant count = 0; 
while (count < n) {
    print(curr);
    immutant next = prev + curr;
    prev = curr;
    curr = next;
    count += 1;
}
\end{verbatim}

\section{Atslēgas vārdi}

Valodā Immutant ir definēti sekojoši atslēgas vārdi, kas ir rezervēti valodas sintaksei un tiem nevar tikt piešķirta cita nozīme:
\begin{itemize}
  \item \texttt{immutant} - tiek lietots, lai deklarētu nemutablus mainīgos
  \item \texttt{mutant} - tiek lietots, lai deklarētu mutablus mainīgos
  \item \texttt{fn} - tiek lietots, lai definētu funkcijas
  \item \texttt{pure} - tiek lietots, lai definētu tīras funkcijas
  \item \texttt{impure} - tiek lietots, lai definētu netīras funkcijas
  \item \texttt{if} - tiek lietots, lai definētu nosacījuma apgalvojumu
  \item \texttt{else} - tiek lietots, lai definētu nosacījuma apgalvojuma alternatīvu
  \item \texttt{while} - tiek lietots, lai definētu ciklu
  \item \texttt{return} - tiek lietots, lai atgrieztu vērtību no funkcijas
  \item \texttt{true} - patiesuma vērtība
  \item \texttt{false} - aplamas vērtība
\end{itemize}

\section{Kļūdas un izņēmumi}

% ImplicitionConversionException
% InvalidTypeConversionException
% UndeclaredVariableException
% InvalidOperationException
% ImmutableVariableModificationException

Neviens vēl nav uzrakstījis nevainojamu programmu no pirmās reizes, tāpēc kļūdas un ar to sasitītā programmu atkļūdošana ir neizbēgama bet dabiska programmēšanas sastāvdaļa. Lai palīdzētu programmētājiem identificēt un novērst kļūdas, Immutant valodas interpretators izmet izņēmumus un kļūdu ziņojumus, kad tiek konstatēta kāda kļūda izpildes laikā. 
\begin{itemize}
  \item \texttt{ImplicitionConversionException} - Tiek izmests, kad tiek konstatēta netieša datu tipu konversija. Visbiežāk tas notiek pielietojot operatorus ar dažādiem datu tipiem, piemēram, saskaitot virkni un skaitli.
  \item \texttt{InvalidTypeConversionException} - Tiek izmests, kad atļautā tiešā veida datu tipu konversija nav iespējama. Piemēram, mēģinot pārvērst virkni, kas nesatur derīgu skaitlisko vērtību, par skaitli.
  \item \texttt{UndeclaredVariableException} - Tiek izmests, kad tiek izmantots mainīgais, kas nav deklarēts (vismaz ne redzamajā redzeslokā). 
  \item \texttt{InvalidOperationException} - Tiek izmests, ja tiek veikta nederīga operācija, piemēram, dalīšana ar nuli.
  \item \texttt{ImmutableVariableModificationException} - Tiek izmests, kad nemutablu mainīgo tiešā vai netiešā (caur netīru funkciju) veidā mēģina mainīt.
  \item \texttt{SyntaxError} - Tiek izmests, ja programkods satur nekorektu sintaksi, kuru interpretators nespēj apstrādāt. (vairāk par sintakses apstrādi skat. nodaļā ~\ref{chap:arch})
\end{itemize}

% TODO: minēt ka ir regulāra valoda.
% TODO: pie arhitektūras apraksta minēti lookahead daudzumu šai valodai
\chapter{Programmatūras Prasību specifikācija}
\label{chap:arch}

Šeit būs info par lekseri, parsētāju un tree walker.

\section{Funkcionālās prasības}

Interpretatora programmatūru iedala 5 moduļos, katrs no tiem atbild par savu funkcionalitāti. Skenēšanas, parsēšanas un izvērtēšanas moduļi veido pašu pamatu interpretēšanai, taču ir nepieciešami arī citi moduļi, lai nodrošinātu pilnvērtīgu programmu - lietotāja saskarnes modulis un interpretatora kodola modulis.

\renewcommand{\arraystretch}{2}
\begin{table}[h]
\centering
\begin{tabular}{p{5.5cm} p{7cm} c}
\toprule
\rowcolor{gray!60}
Modulis & Funkcija & Identifikators \\
\midrule

\multirow{2}{*}{Lietotāja saskarnes modulis}
    & Pirmkoda interpretēšana no datnes & CLI-1 \\
\cmidrule(lr){2-3}
    & REPL režīma palaišana & CLI-2 \\
\midrule

\multirow{1}{*}{Interpretatora kodola modulis}
    & Interpretēšanas piespiedu apstādināšana & CORE-1 \\

\midrule

\multirow{3}{*}{Skenēšanas modulis}
    & Rakstzīmju pārveidošana uz leksēmu zīmogiem & LEX-1 \\
\cmidrule(lr){2-3}
    & Burtciparu ne-virkņu vērtību skenēšana  & LEX-2 \\
\cmidrule(lr){2-3}
    & Literālo vērtību skenēšana & LEX-3 \\
  
\midrule

\multirow{2}{*}{Parsēšanas modulis}
    & Leksēmu parsēšana uz AST kokiem & PARSE-1 \\
\cmidrule(lr){2-3}
    & Parsētāja sinhronizēšana pēc notikušās parsēšanas kļūdas  & PARSE-2 \\
  
\midrule

\multirow{3}{*}{Izvērtēšanas modulis}
    & AST koka izvērtēšana & EVAL-1 \\
\cmidrule(lr){2-3}
    & Izteiksmes AST koka izvērtēšana & EVAL-2 \\
\cmidrule(lr){2-3}
    & Priekšraksta AST koka izvērtēšana & EVAL-3 \\
  
\midrule
\end{tabular}
\caption{Funkciju sadalījums pa moduļiem}
\end{table}

\begin{figure}[h]   
    \centering
    \includegraphics[scale=0.6]{assets/dataflow/dfd_lvl_1.jpg}  
    \vspace{0.5cm}  
    \caption{1. līmeņa datu plūsmas diagramma}           % optional
    \label{fig:dfd_lvl_1}                  
\end{figure}

\FloatBarrier

\begin{figure}[h]   
    \centering
    \includegraphics[scale=0.6]{assets/dataflow/dfd_lvl_1.jpg}  
    \vspace{0.5cm}  
    \caption{1. līmeņa datu plūsmas diagramma}           % optional
    \label{fig:dfd_lvl_1}                  
\end{figure}

\FloatBarrier

\renewcommand{\arraystretch}{1.3}  % increase row height

\begin{longtable}{%
    >{\raggedright\arraybackslash}c
    >{\raggedright\arraybackslash}p{0.75\textwidth}
}
\toprule
\rowcolor{gray!20}
Paziņojuma identifikators & Paziņojuma apraksts \\
\midrule
SYNTAX\_ERR-1 & Ja skeneris sagaida virknes beigu simbolu, bet to neatrod, parāda paziņojumu: ``Unterminated string literal''. \\
\midrule
SYNTAX\_ERR-2 & Ja skaitlis neatbilst valodas specifikācijai, parāda paziņojumu: ``Invalid number''. \\
\midrule
SYNTAX\_ERR-3 & Ja skeneris neatpazīst leksēmas tipu, t.i., tā neeksistē valodas alfabētā, parāda paziņojumu: ``Invalid token: \texttt{<lexeme>}''. \texttt{<lexeme>} tiek aizstāts ar neatpazītās leksēmas vērtību. \\
\midrule
SYNTAX\_ERR-4 & Ja parsētājs neatrod atverošo iekavu nosacījuma izteiksmei, parāda paziņojumu: ``Expected '(' after \texttt{condition\_source}``. \texttt{<condition\_source>} ir nosacījuma izteiksmes lietotājs - \texttt{if} vai \texttt{while} priekšraksti. \\
\midrule
SYNTAX\_ERR-5 & Ja izteiksme ir grupēta iekavās vai ir daļa no nosacījuma un pēc tās neseko aizverošā iekava, parāda paziņojumu: ``Expected ')' after expression``. \\
\midrule
SYNTAX\_ERR-6 & Ja priekšraksta beigās nav atrodamas semikola zīmes, parāda paziņojumu: ``Expected ';' after \texttt{<expr\_type>}''. `<expr\_type>` ir vai nu \texttt{expression statement} vai \texttt{variable declaration} atkarībā no priekšraksta. \\
\midrule
SYNTAX\_ERR-7 & Ja priekšraksts ir bijis atverošais pirmkoda bloks, bet aizverošā figūriekava netika atrasta, tad parāda paziņojumu: ``Expected '\}' after block statement`` \\
\midrule
SYNTAX\_ERR-8  & Ja funkcijas izsaukumā padotais argumentu saraksts netiek noslēgts ar aizverošo iekavu, tad parāda paziņojumu: ``Expect ')' after arguments.``      \\
\midrule
SYNTAX\_ERR-9  & Ja parsētājs neatrod izteiksmi, kur tai būtu jābūt, parāda paziņojumu: ``Expected expression``.                                                     \\
\midrule
SYNTAX\_ERR-10 & Ja piesķiršanas operatora kreisas operands nav derīgs, lai izpildītu operāciju (nav lvalue), tad parāda paziņojumu: ``Invalid assignment target.``. \\
\midrule

RUNTIME\_ERR-1 & Ja dalīšanas operācijai padots dalītājs 0, tad parāda paziņojumu: ``Division by zero is illegal``.                                                                                                                                      \\

\midrule

RUNTIME\_ERR-2 & Ja lietotājs izmanto mainīgo vidē, kur tas nav deklarēts un neeksistē, tad parāda paziņojumu: ``Undefined variable: \textless{}t\textgreater{}``. \textless{}t\textgreater tiek aizvietots ar attiecīgā mainīgā nosaukumu.              \\
\midrule

RUNTIME\_ERR-3 & Ja operācijas operandu tipi neatbilst valodas specifikācijai, tad parāda paziņojumu ``Expected a \textless{}t\textgreater value``. \textless{}t\textgreater tiek aizvietots ar atbilstošu datu tipu, ko izvērtēšanas modulis sagaidīja. \\
\midrule

RUNTIME\_ERR-4 & Ja operatoram + abi operandi nav vienādā tipa un nav ne virknes ne skaitļu tipa, tad parāda paziņojumu: ``Operands to '+' must be both numbers or both strings``.                                                                       \\
\midrule
RUNTIME\_ERR-5 & Ja abi dalīšanas operācijas operandi nav skaitļi, izmet paziņojumu: ``Operands to '/' must be numbers``.                                                                                                                                \\
\midrule
RUNTIME\_ERR-6 & Ja funkcijas izsaukuma saucējs nav derīga funkcija, tad parāda paziņojumu: ``Callee is not a function``.                                                                                                                                \\
\midrule
RUNTIME\_ERR-7 & Ja mainīgais ar tādau pašu nosaukumu ir jau iepriekš deklarēts, parāda paziņojumu: ``Variable already defined: \textless{}t\textgreater{}``. \textless{}t\textgreater tiek aizstāts ar attiecīgu mainīgā nosaukumu.                      \\
\midrule
RUNTIME\_ERR-8 & Ja funkcija tiek izsaukta ar argumentu skaitu, kas atškirās no parametru skaita funkcijas definīcijā, parāda paziņojumu: ``Incorrect number of arguments passed to function``.                                                          \\
\midrule
RUNTIME\_ERR-9 & Ja tīras funkcijas izsaukumā tiek padots arguments ka ir mutabls mainīgais, parāda paziņojumu: ``Cannot pass mutable argument to impure function``.                                                                                  \\
\bottomrule
\caption{Kļūdu paziņojumu apraksts}
\end{longtable}

\section{Skenēšanas modulis}

Skenēšanas modulis ir atbildīgs par pirmkoda pārvēršanu leksēmās. Skenēšanas modulis izmanto leksisko analīzi, lai identificētu un kategorizētu pirmkoda elementus, piemēram, atslēgvārdus, operatorus, literālas vērtības un identifikatorus.


\FloatBarrier

\begin{figure}[h]   
    \centering
    \includegraphics[scale=0.6]{assets/dataflow/dfd_lexer.jpg}  
    \vspace{0.3cm}  
    \caption{Skenēšanas moduļa 2.līmeņa DPD}
    \label{fig:dfd_lexer}                  
\end{figure}

\FloatBarrier

\renewcommand{\arraystretch}{1.7}

\begin{longtable}{%
  >{\raggedright\bfseries}p{0.25\textwidth}
  >{\raggedright\arraybackslash}p{0.65\textwidth}
  c
}
\toprule
\rowcolor{gray!20}
Identifikators: & LEX-1 & \\
\midrule
Nosaukums: & Rakstzīmju pārveidošana uz leksēmu zīmogiem & \\
\midrule
Mērķis: & Pārvērst pirmkodu leksēmās & \\
\midrule
Ievaddati: & Lietotāja pirmkods & \\
\midrule
Apstrāde: &
Skeneris dotajā secībā iziet cauri katram simbolam un pārvērš to atbilstošā leksēmā, veicot nepieciešamās papildfunkcijas pilnu leksēmu vērtību nolasīšanai, ja leksēma nesastāv tikai no vienas rakstzīmes. & \\
\midrule
Izvaddati: & Leksēmas un skenēšanas kļūdas, ja tādas radušās procesā. & \\
\midrule
\multirow{1}{*}{Kļūdu paziņojumi:} & SYNTAX\_ERR-1\\
\cmidrule(lr){2-3}
& SYNTAX\_ERR-2 \\
\cmidrule(lr){2-3}
& SYNTAX\_ERR-3 \\

\bottomrule
\caption{Funkcijas LEX-1 apraksts}
\end{longtable}
\vspace{0.8cm}

\renewcommand{\arraystretch}{1.7}

\begin{longtable}{%
  >{\raggedright\bfseries}p{0.25\textwidth}
  >{\raggedright\arraybackslash}p{0.65\textwidth}
  c
}
\toprule
\rowcolor{gray!20}
Identifikators: & LEX-2 & \\
\midrule
Nosaukums: & Literālo vērtību skenēšana & \\
\midrule
Mērķis: & Noskaidrot pilnas leksēmu vērtības kā literālus & \\
\midrule
Ievaddati: & Lietotāja pirmkods, leksēmas vērtības sākuma simbols, kas indicē, ka leksēma varētu būt noteikta tipa vērtība & \\
\midrule
Apstrāde: & Tiek noskaidrots vai leksēma var būt skaitlis vai virkne. Ja tas ir skaitlis, tad skeneris iteratīvi nolasa ciparu aiz ciparu, ļaujot vienam punkta simbolam atrasties šajā skaitlī, kas apzīmētu decimāldaļu. Virknes gadījuma skeneris noalasa visus simbolus sākot at atverošo un beidzot ar aizverošo pēdiņas simbolu. & \\
\midrule
Izvaddati: & Leksēmas pilna vērtība un skenēšanas kļūdas, ja tādas radušās procesā. & \\
\midrule
\multirow{1}{*}{Kļūdu paziņojumi:} & SYNTAX\_ERR-1\\
\cmidrule(lr){2-3}
& SYNTAX\_ERR-2 \\

\bottomrule
\caption{Funkcijas LEX-2 apraksts}
\end{longtable}
\vspace{0.8cm}

\renewcommand{\arraystretch}{1.7}

\begin{longtable}{%
  >{\raggedright\bfseries}p{0.25\textwidth}
  >{\raggedright\arraybackslash}p{0.65\textwidth}
  c
}
\toprule
\rowcolor{gray!20}
Identifikators: & LEX-3 & \\
\midrule
Nosaukums: & Burtciparu ne-virkņu vērtību skenēšana & \\
\midrule
Mērķis: & Noskaidrot vai dotā vērtība ir valodā rezervēts atslēgvārds vai lietotāja definēts identifikators & \\
\midrule
Ievaddati: & Lietotāja pirmkods, leksēmas vērtības sākuma simbols, kas indicē, ka leksēmai jābūt burtciparu ne-virknes vērtībai & \\
\midrule
Apstrāde: & Funkcija pārbauda, vai dotā vērtība neatbilst precīzi kādam no valodā rezervētiem atslēgvārdiem. Pretējā gadījumā tiek atgriezta informācija, ka leksēma ir lietotāja definēts identifikators. & \\
\midrule
Izvaddati: & Burtciparu ne-virkņu datu tips un vērtība & \\
\midrule
Kļūdu paziņojumi: & - \\

\bottomrule
\caption{Funkcijas LEX-3 apraksts}
\end{longtable}
\vspace{0.8cm}

\section{Parsēšanas modulis}

Parsēšanas modulis ir atbildīgs par leksēmu pārvēršanu abstraktā sintakses kokā (AST). Parsēšanas modulis izmanto sintaktisko analīzi, lai identificētu un strukturētu pirmkoda elementus, piemēram, izteiksmes, apgalvojumus un priekšrakstus.


\FloatBarrier

\begin{figure}[h]   
    \centering
    \includegraphics[scale=0.6]{assets/dataflow/dfd_parser.jpg}  
    \vspace{0.3cm}  
    \caption{Parsēšanas moduļa 2.līmeņa DPD}
    \label{fig:dfd_parser}                  
\end{figure}

\FloatBarrier

\renewcommand{\arraystretch}{1.7}

\begin{longtable}{%
  >{\raggedright\bfseries}p{0.25\textwidth}
  >{\raggedright\arraybackslash}p{0.65\textwidth}
  c
}
\toprule
\rowcolor{gray!20}
Identifikators: & PARSE-1 & \\
\midrule
Nosaukums: & Leksēmu parsēšana uz AST kokiem & \\
\midrule
Mērķis: & Pārvērst leksēmas abstraktā sintakses kokā (AST), lai pirmkoda izvērtēšana būtu iespējama & \\
\midrule
Ievaddati: & Leksēmas no lietotāja pirmkoda & \\
\midrule
Apstrāde: & Parsētājs izmanto rekursīvo nolaišanās algoritmu, parsējot leksēmas no gramatikas sākuma produkcijas līdz pat dziļākajai produkcijai, lai nodrošināti viennozīmīgu AST koka uzbūvi, respektējot uzdotās izteiksmju prioritātes. & \\
\midrule
Izvaddati: & AST koki un parsēšanas kļūdas, ja tādas radušās procesā. & \\
\midrule
\multirow{1}{*}{Kļūdu paziņojumi:} & SYNTAX\_ERR-4\\
\cmidrule(lr){2-3}
& SYNTAX\_ERR-5 \\
\cmidrule(lr){2-3}
& SYNTAX\_ERR-6 \\
\cmidrule(lr){2-3}
& SYNTAX\_ERR-7 \\
\cmidrule(lr){2-3}
& SYNTAX\_ERR-8 \\
\cmidrule(lr){2-3}
& SYNTAX\_ERR-9 \\
\cmidrule(lr){2-3}
& SYNTAX\_ERR-10 \\

\bottomrule
\caption{Funkcijas PARSE-1 apraksts}
\end{longtable}
\vspace{0.8cm}

\renewcommand{\arraystretch}{1.7}

\begin{longtable}{%
  >{\raggedright\bfseries}p{0.25\textwidth}
  >{\raggedright\arraybackslash}p{0.65\textwidth}
  c
}
\toprule
\rowcolor{gray!20}
Identifikators: & PARSE-2 & \\
\midrule
Nosaukums: & Parsētāja sinhronizēšana pēc notikušās parsēšanas kļūdas & \\
\midrule
Mērķis: & Parsēšanas kļūdas gadījumā nodot parsētājam informāciju, no kuras leksēmas ir jēgpilni atsākt parsēšanu. Tas tiek darīts, lai lietotājs uzzinātu pēc iespējams vairāk kļūdu, ko ir veicis pirmkoda sintaksē, bet tajpat laikā nodrošināt, ka turpmākā parsēšana nerada viltotus AST vai neloģiskas kļūdas. & \\
\midrule
Ievaddati: & Leksēmu masīvs un ziņa par pēdējo apstrādāto leksēmu & \\
\midrule
Apstrāde: & Funkcija iet pāri leksēmu masīvam, kamēr neatrod leksēmu, no kuras ir sagaidāms, ka sākas jauns priekšraksts, piemēram, mainīgā deklarācija. & \\
\midrule
Izvaddati: & Jauna pozīcija leksēmu masīvā, no kuras ir jēgpilni atsākt parsēšanu & \\
\midrule
Kļūdu paziņojumi: & - \\

\bottomrule
\caption{Funkcijas PARSE-2 apraksts}
\end{longtable}

\newpage
\section{Izvērtēšanas modulis}

Izvērtēšanas modulis ir atbildīgs par AST koku izvērtēšanu un programmas izpildi. Šis modulis ir pēdējais solis interpretācijas procesā, kur AST koks tiek pārvērsts par faktiskām darbībām un rezultātiem, kas atspoguļo lietotāja rakstītā pirmkoda ieceres.

\FloatBarrier

\begin{figure}[h]   
    \centering
    \includegraphics[scale=0.6]{assets/dataflow/dfd_eval.jpg}  
    \vspace{0.3cm}  
    \caption{Izvērtēšanas moduļa 2.līmeņa DPD}
    \label{fig:dfd_eval}                  
\end{figure}

\FloatBarrier

\renewcommand{\arraystretch}{1.7}

\begin{longtable}{%
  >{\raggedright\bfseries}p{0.25\textwidth}
  >{\raggedright\arraybackslash}p{0.65\textwidth}
  c
}
\toprule
\rowcolor{gray!20}
Identifikators: & EVAL-1 & \\
\midrule
Nosaukums: & AST koka izvērtēšana & \\
\midrule
Mērķis: & Izvērtēt AST koku un veikt darbības, kas atbilst lietotāja rakstītā pirmkoda loģikai un semantikai. & \\
\midrule
Ievaddati: & pirmkods noparsēts AST kokos & \\
\midrule
Apstrāde: & Funkcija novērtē, vai dotais AST koks atbilst priekšrakstam vai izteiksmei, un nodot kontroli atbilstošai apstrādes funkcijai.  & \\
\midrule
Izvaddati: & Izpildīts priekšraksta efekts, pēdējā izvērtētā vērtība no priekšraksta saturošām izteiksmēm & \\
\midrule
\multirow{1}{*}{Kļūdu paziņojumi:} & RUNTIME\_ERR-1\\
\cmidrule(lr){2-3}
& RUNTIME\_ERR-2 \\
\cmidrule(lr){2-3}
& RUNTIME\_ERR-3 \\
\cmidrule(lr){2-3}
& RUNTIME\_ERR-4 \\
\cmidrule(lr){2-3}
& RUNTIME\_ERR-5 \\
\cmidrule(lr){2-3}
& RUNTIME\_ERR-6 \\
\cmidrule(lr){2-3}
& RUNTIME\_ERR-7 \\
\cmidrule(lr){2-3}
& RUNTIME\_ERR-8 \\
\cmidrule(lr){2-3}
& RUNTIME\_ERR-9 \\

\bottomrule
\caption{Funkcijas EVAL-1 apraksts}
\end{longtable}
\vspace{0.8cm}

\renewcommand{\arraystretch}{1.7}

\begin{longtable}{%
  >{\raggedright\bfseries}p{0.25\textwidth}
  >{\raggedright\arraybackslash}p{0.65\textwidth}
  c
}
\toprule
\rowcolor{gray!20}
Identifikators: & EVAL-2 & \\
\midrule
Nosaukums: & Izteiksmes AST izvērtēšana & \\
\midrule
Mērķis: & Izvērtēt izteiksmes AST & \\
\midrule
Ievaddati: & Izteiksme AST formātā & \\
\midrule
Apstrāde: & Funkcija nosaka izteiksmes veidu un atbilstoši tam palaiž dotās izteiksmes izvērtēšanas algoritmu. & \\
\midrule
Izvaddati: & Izteiksmes vērtība, izpildīts efekts, ja tāds ir, piemēram, vērtības piešķiršana mainīgam & \\
\midrule
\multirow{1}{*}{Kļūdu paziņojumi:} & RUNTIME\_ERR-1\\
\cmidrule(lr){2-3}
& RUNTIME\_ERR-2 \\
\cmidrule(lr){2-3}
& RUNTIME\_ERR-3 \\
\cmidrule(lr){2-3}
& RUNTIME\_ERR-4 \\
\cmidrule(lr){2-3}
& RUNTIME\_ERR-5 \\
\cmidrule(lr){2-3}
& RUNTIME\_ERR-6 \\
\cmidrule(lr){2-3}
& RUNTIME\_ERR-7 \\
\cmidrule(lr){2-3}
& RUNTIME\_ERR-8 \\
\cmidrule(lr){2-3}
& RUNTIME\_ERR-9 \\

\bottomrule
\caption{Funkcijas EVAL-2 apraksts}
\end{longtable}
\vspace{0.8cm}

\renewcommand{\arraystretch}{1.7}

\begin{longtable}{%
  >{\raggedright\bfseries}p{0.25\textwidth}
  >{\raggedright\arraybackslash}p{0.65\textwidth}
  c
}
\toprule
\rowcolor{gray!20}
Identifikators: & EVAL-3 & \\
\midrule
Nosaukums: & Priekšraksta AST izvērtēšana & \\
\midrule
Mērķis: & Izvērtēt priekšraksta AST & \\
\midrule
Ievaddati: & Priekšraksta AST koka izvērtēšana & \\
\midrule
Apstrāde: & Funkcija nosaka priekšraksta veidu un palaiž tam atbilstošu izvērtēšanas algoritmu. Tā kā priekšraksti sastāv no izteiksmēm, tas izmanto funkciju EVAL-2, lai sekmīgi izvērtētu visu priekšrakstu. & \\
\midrule
Izvaddati: & Izpildīts priekšraksta efekts, pēdējā izvērtētā vērtība no priekšraksta saturošām izteiksmēm & \\
\midrule
Kļūdu paziņojumi: & Funkcijas daļa, kas dara unikālu darbu, neveido nevienas kļūdas, tomēr iekšēji tā arī izmanto izteiksmju izvērtēšanu, tāpēc ši funkcijas realitātē rada visus paziņojumus no funckijas EVAL-2 \\
\caption{Funkcijas EVAL-3 apraksts}
\end{longtable}


\nocite{crafting-interpreters}
\bibliographystyle{plain}
\bibliography{references}   


\end{document}
