\documentclass[12pt,a4paper]{report}

\usepackage{formatting}
\usepackage{tabularx}
\usepackage{cite}  % optional, improves formatting


\title{LATVIJAS UNIVERSITĀTE
EKSAKTO ZINĀTŅU UN TEHNOLOĢIJU FAKULTĀTE}

\author{Rolands Frīdemanis}


\begin{document}

\begin{titlepage}
    \centering
    
    {\Large LATVIJAS UNIVERSITĀTES\\EKSAKTO ZINĀTŅU UN TEHNOLOĢIJU FAKULTĀTES DATORIKAS NODAĻA\\[5cm]}
    
    {\LARGE \textbf{ INTERPRETATORS PROGRAMMĒŠANAS\\[0.3cm] VALODAI IMMUTANT}}\\[0.5cm]

    \normalsize{KVALIFIKĀCIJAS DARBS DATORZINĀTNĒS}\\[5cm]
    
    \begin{flushleft}
        Autors: Rolands Frīdemanis\\
        Studenta apliecības Nr.: rf23009\\
        Darba vadītājs: asociētais profesors Dr. sc. comp. Aleksandrs Belovs
    \end{flushleft}
    
    \vfill
    RĪGA, 2025
\end{titlepage}

\selectlanguage{latvian} 
\begin{abstract}
    Mūsdienās liela daļa no vispārīga pielietojuma programmēšanas valodām, satur sematiku, kas paredz, ka datu mainība ir ierasta lieta, tomēr šim pastāv būtisks trūkums, kas ir datu neparedzamība.
    Lai spriešanu par programmas stāvokli padarītu paredzamu, šī darba ietvaros tiek izstrādāta programmēšanas valoda, kuras gramatika un sintakse ierosina noteikta datu nemainību.
    Šis darbs satur valodas specifikāciju un interpretatora arhitektūras dokumentāciju lekserim, parsētājam un abstraktā sintakses koka pārstaigāšanas algoritmam.
    Rezultātā, izmantojot valodu C, tiek izveidota augsta līmeņa, intepretējama, dinamiski tipizēta valoda ar atomāriem datu tipiem.

    \begin{flushleft}
    \textbf{Atslēgvārdi:} interpretators, AST, funkcionālā programmēšana, C valoda, datu nemainība
    \end{flushleft}
\end{abstract} 

\selectlanguage{english} 
\begin{abstract}
    Most modern general-purpose programming languages use grammar and syntax that suggests mutable data being an ordinary matter, which in reality complicates reasoning about program state.
    To make such reasoning predictable, this work explores the design and delelopment of a programming language with explicit syntax and semantics of immutable data. 
    This work contains specification for such language and documentation of the architecture for the lexer, parser and AST-walker of the underlying interpreter.
    As a result, a high-level, interpreted, dynamically typed programming language with only atomic data types is created. The language is implemented in C.

    \begin{flushleft}
    \textbf{Keywords:} interpreter, AST, functional programming, C language, data immutability
    \end{flushleft}
\end{abstract} 

\selectlanguage{latvian} 
\tableofcontents

\newpage
\chapter*{Apzīmējumu saraksts}
\addcontentsline{toc}{section}{Apzīmējumu saraksts} 


\begin{tabular}{ll} 
\textbf{AST} & Abstraktās sintakses koks \\
\textbf{immutability} & Pilnīga datu nemainība (koncepts) \\
\textbf{immutable} & Nemainīgs (datu īpašība) \\
\textbf{read-only} & Tikai lasāmi (dati)
\end{tabular}


\newpage
\chapter*{Ievads}
\addcontentsline{toc}{section}{Ievads}

Datu mainība un to nepārtraukta plūsma no viena mainīga uz otru ir neapstrīdama daļa no lielas daļas programmatūras. Droši var apgalvot, ka datorsistēmu arhitektūru atmiņas koncepcija ļauj izmantot atmiņu vairākkārtēji. Atmiņu var relocēt, izdzēst, pieprasīt lielākus atmiņas gabalus u.t.t. No šī izriet datu mainības būtība, un līdz šai dienai tā ir iekalta lielā daļā, ja ne visu, programmēšanas un skriptēšanas valodu.   

No otras puses, mainīgiem datiem pastāv īpašība būt neparedzamiem. Kamēr mazas sistēmas spēj tikt galā ar nelielu daudzumu mainīgo, tad lielajās sistēma tas var kļūt par acīmredzamu problēmu. Atmiņa datoram ir viena, tomēr atsaukties uz to var no dažādām vietām dažādos laika brīžos, kas padara spriešanu par datu stāvokli daudz sarežģītāk.  

Programmētāji izmanto iespēju mainīt datus brīvā veidā, jo  programmēšanas valodas un to abstrakcijas ir padarījušas to tik vienkāršu. Lai gūtu vairāk kontroles pār ipriekš minēto uzvedību, valodas no C saimes, Java, JavaScript un citas valodas satur gramatikas, kas ierobežo mainīgu datu inicializāciju un to turpmāko vērtību maiņu. Kā piemēru var minēt \texttt{const} atslēgvārdu no valodas C, kas fiksē doto mainīgo un liedz pārrakstīt tā vērtību, tomēr tas tikai daļēji attiecas uz atsauces tipa vērtībām. Kaut arī šāda tipa mainīgais vienmēr atsauksies tikai uz vienu konkrētu atmiņas apgabalu, nav noteikts, ka vērtība, kas tajā atrodas, nemainīsies. Līdz ar to, \texttt{const} atslēgvārds negarantē patiesu datu nemainību, bet tikai noslēdz to uz \texttt{readonly} pieeju.
Neskatoties uz dažāiem programmēšanas valodu centieniem ierobežot datu mainību, tādas problēmas kā neparedzamas mainīgo vērtības pavedienu izpildes laikā, mainīgo aizstājējvārdu nepārdomāta ieviešana un izmantošana, mainīgo nejauša re-inicializācija u.c. joprojām sastāda lielu daļu programmu.\cite{immutability}

Šis darbs izskata jaunas interpretējamas programmēšanas valodas izveidi, kurai pielietota datu nemainības semantika, cenšoties mazināt programmatūras izstrādes problēmas saistītas ar stāvoklu maiņu. Tas arī nozīmē, ka galvenā ideja kalpo far faktoru valodas nosaukuma izvēlei. Savukārt interpretatora sākotnējā versijā, kas šeit ir izskatīta, ietilpst apstrādes loģika sekojošām daļām: primitīvi datu tipi un to glabāšana mainīgos, ar to saistītā datu nemainības semantika, izteikumi, tīras un netīras funckijas, kontroles plūsma un cikli.

% TODO: check if the promoted features are included in the final version and if there is somethign missing or something over-pomised.

Šī darba pirmajā nodaļā tiks izskatīta programmēšanas valodas specifikācija, kurai pakārtosies interpretators. Savukārt otrā nodaļa būs veltīta interpretatora arhitektūras pārskatam un tā tehniskai specifikācijai, kā arī tehnoloģijām izmantotām porgrammatūras izstrādei. Trešā un ceturtā nodaļa virzīs uzmanību uz leksera un parsētāja izstrādes detaļām, bet piektā nodaļa būs par rezultējošā AST apstrādi. Tālākajā sestajā nodaļā būs apokopoti rezultāti par jauniegūto valodu un tās interpretatoru, un praktiski demonstrēts valodas pielietojums. Visbeidzot, septītajā nodaļā tiek izvirzītas idejas turpmākai valodas attīstībai, un izskatīts kopsavilkums par paveikto darbu.


\newpage
\chapter{Valodas specifikācija}

Šīs nodaļas nolūks ir formalizēt prasības, kas noteiktas uz valodu, kas attiecīgam interpretatoram ir jāspēj īstenot. Šī nodaļa neizklāsta implementācijas detaļas, bet gan drīzāk kalpo kā lietotāja rokasgramāta valodas lietošanā.
Nodaļā izklāstītā informācija netikai palīdz lasītājiem iepazīties ar tās uzbūvi valodas lietošanas un attīstīstīšanas nolūkos, bet arī nosaka prasības, kas tiek attiecīgi nostādītas uz Immuntant programmēšanas valodas interpretatoru.
Nodaļā ir skaidroti valodā definētie datu tipi, mainīgie funkcijas, un programmas vadības mehānismi, datu nemainības semantika, kas attiecas uz noteikta veida vērtībām, kā arī tiek uzskaitīti kļūdu paziņojumi un to attiecīgie skaidrojumi.
Turpretim, lai iepazītos ar tehniskām implementācijas detaļām, skatīt nākamo nodaļu ~\ref{chap:arch}.

\section{Datu tipi}

Immutant valodā tiek definēti tikai primitīvi datu tipi, kurus iedala 3 kategorijās: patiesuma, virknes tipa, un skaitļi. Par katru no šiem zemāk seko savs skaidrojums.


\subsection{Virknes}
\textbf{Definīcija}

Vikrne ir jebrkuš simbolu kopums, kas ir ietverts starp dubultpēdiņām.

Virknes var saturēt jebkādus simbolus, tostarp specsimbolus, kā \texttt{@,\^\space,\&} u.c. Proti, vikrnēs arī nav liegts izmantot speciālos atslēgas vārdus, ko pati valoda ir definējusi, piemēram, \texttt{mutant} (vairāk par to minēts sadaļā ~\ref{section:vars}).
Piemērs dažādām viknēm seko zemāk. Tāpat, arī vienu rakstzīmi ir atļauts uzdot ar virknes tipu.

\begin{verbatim}
"", "someString", "sentence with spaces", " ", ,"\""
\end{verbatim}

Izņēmuma gadījums, ir dubultpēdiņu simbola izmantošana iekš vikrnes. Lai nezutvertu to kā virknes beigas, tas ir jāekranē ar vadošo simbolu \texttt{\textbackslash}. Realitātē neekranizētas virknes, kas satur specsimbolus ir pamata sintakses kļūda, ko programmētāji bieži vien pieļauj neuzmanības dēļ. 

Piemērs tādai virknei:

\begin{verbatim}
"They call themselves \"the wolves\""
\end{verbatim}

Rezultātā atkārtots dubultpēdiņu simbols netiek uztvers kā virknes beigu indenkators, bet gan kā daļa no virknes vērtības, un tiek panākts sekojošs teksts:

\begin{verbatim}
They call themselves "the wolves"
\end{verbatim}

Uz ekranizēšanu attiecas arī pats ekranizēšanas simbols \texttt{\textbackslash}. Ja ir nepieciešamība to iekļaut virknē, tas arī ir jāekranizē sekojošā veidā:

\begin{verbatim}
"There is something mysterious about the \"\\\" character."
\end{verbatim}

Dotās virknes rezultējošais teksts ir: 

\begin{verbatim}
There is something mysterious about the "\" character.
\end{verbatim}

\subsection{Skaitļi}
\textbf{Definīcija}

Skaitlis ir jebkura vērtība no Reālo skaitļu kopas. Ir svarīgi uzsvērt, ka irracionāli skaitļi tiek implementēti pēc IEEE 754 standarta, tāpēc realitātē tie nav līdz galam irracionāli, bet gan ir to aproksimētas vērtības. Daļskaitļu decimālo daļu atdala ar punkta (\char`.) rakstzīmi.

Piemērs skaitliskām vērtībām seko zemāk:

\begin{verbatim}
102, -9, -0.3, 421.5632, PI
\end{verbatim}

Dotajā piemērā \texttt{PI} ir viena no valodā eksistējošām konstatēm, kas satur aproksimētu matemātiskās konstantes $\pi$ vērtību (\texttt{\char`~3.1415926535}).

Valodas gramatika atļauj izmantot vadošo punktu priekšā skaitlim, kas apzīmē decimāldaļu skailim nulle. Piemēram, decimālskaitlis \texttt{.34} ir identisks ar \texttt{0.34}.


\subsection{Patiesuma vērtības}

\textbf{Definīcija}

Patiesuma vērtības ir tādas vērtības, kuras ir vai nu patiesas vai nu aplamas.

No augstāk redzamās definīcijas iziriet, ka valodai Immutant tiek definēta divvērtīga loģika. Tātad, patiesu vērtību apzīmē ar \texttt{true}, bet aplamu ar \texttt{false.}

\section{Konstrukcijas}

\subsection{Izteikumi}

Izteikumi mēdz būt dažādi - tie var gan neproducēt neko, gan arī producēt kādu vērtību. Piemēram, mainīgo inicializācijas izteikums pēc būtības ir izpidāma komanda, toties tā rezultātā pati par sevi nedod nekādu vērtību. No otras puses jebkurš salīdzināšanas operators, piemēram "ir vienāds" jeb \texttt{==} (detalizētāk par to skat. ~\ref{section:operators}), producē patiesuma vērtību, kas izsaka salīdzināšanas rezultātu.

\subsection{Operatori}
\label{section:operators}

Operatorus iedala unāros un bināros. Unārs operators tiek pielietots tikai vienam operandam, kur tai pat laikā bināri operatori ir pielietoti 2 operandiem. Piemmēram, negācijas operators, kas apvērš patiesuma vērtību ir pielietots vienam operatoram, bet saskaitīšanas operators ir pielietots diviem skaitļiem, producējot to summu.\\

\textbf{Aritmētiskie operatori:} tiek pielietoti skaitļiem, un atgriež skaitlisku vērtību.

\begin{itemize}
  \item \texttt{+} saskaitīšana, atgriež divu skaitļu summu
  \item \texttt{-} atņemšana, atgriež pirmā skaitļa vērtību mīnus otrā skaitļa vērtību
  \item \texttt{*} reizināšana, atgriež divu skaitļu reizinājumu
  \item \texttt{/} dalīšana, atgriež kreisā operanda dalījumu ar labo operandu. Ja labais operands ir nulle, tad tiek izmests izņēmums \texttt{DivisionByZeroException}
  \item \texttt{\%} modulis, atgriež kreisā skaitļa operanda moduli ar labā operanda vērtību
\end{itemize}

\textbf{Skaitliskās salīdzināšanas operatori:} tiek pielietoti skaitļiem, un atgriež patiesuma vērtību. Ja vien izteiksme ar operatoru neatgrieš \texttt{true} patiesuma vērtību, tad tā atgriež \texttt{false}.
\begin{itemize}
  \item \texttt{>} lielāks par, atgriež vērtību, ja kreisā operanda vērtība ir lielāka par labā operanda vērtību
  \item \texttt{<} mazāks par, atgriež patiesuma vērtību, ja kreisā operanda vērtība ir mazāka par labā operanda vērtību
  \item \texttt{>=} lielāks vai vienāds ar, atgriež patiesuma vērtību, ja kreisā operanda vērtība ir lielāka vai vienāda ar labā operanda vērtību
  \item \texttt{<=} mazāks vai vienāds ar, atgriež patiesuma vērtību, ja kreisā operanda vērtība ir mazāka vai vienāda ar labā operanda vērtību
\end{itemize}

\textbf{Ekvivalences operatori:} tiek pielietoti jebkura datu tipa operandiem un atgriež patiesuma vērtību.
\begin{itemize}
  \item \texttt{==} ir vienāds ar, atgriež patiesuma vērtību, ja abu operandus vērtības ir vienādas. Tai skaitā atgriež \texttt{false}, ja abi operandi ir ar dažādiem datu tipiem.
  \item \texttt{!=} nav vienāds ar, atgriež patiesuma vērtību, ja abu operandus vērtības nav vienādas. Tai skaitā atgriež \texttt{true}, ja abi operandi ir ar dažādiem datu tipiem.
\end{itemize}

\textbf{Loģiskie operatori:} Pielietoti patiesuma vērtībām, un atgriež patiesuma vērtību.
\begin{itemize}
  \item \texttt{!} nēgācija, apvērš patiesuma vērtību. Ir unārs operators. 
  \item \texttt{\&\&} konjukcija, atgriež \texttt{true} vērtību, ja abu operandus vērtības ir patiesas
  \item \texttt{||} disjunkcija, atgriež \texttt{true} vērtību, ja vismaz viena no abu operandu vērtībām ir patiesa.
\end{itemize}



\subsection{Mainīgie}
\label{section:vars}

Valoda nošķir 2 veidu manīgos: tie kas nepaļaujas datu mutācijai jeb mainībai un tie, kas tai paļaujas.



\begin{verbatim}
mutant a = 3;
immutant b = 3;
\end{verbatim}


\section{Kļūdu veidi un apzīmējumi}

% TODO: minēt ka ir regulāra valoda.
% TODO: pie arhitektūras apraksta minēti lookahead daudzumu šai valodai
\chapter{Interpretatora arhitektūra}
\label{chap:arch}

Šeit būs info par lekseri, parsētāju un tree walker.


\bibliographystyle{plain}
\bibliography{references}   


\end{document}
